import {
  TINYSLICE_PREFIX,
  isNotNullish
} from "./chunk-STZFUGGS.js";
import {
  Subscription,
  debounceTime,
  tap
} from "./chunk-NWFPIOKI.js";
import {
  __publicField
} from "./chunk-F3FYYIAV.js";

// ../../node_modules/.pnpm/@tinyslice+hydration-plugin@0.8.0/node_modules/@tinyslice/hydration-plugin/index.js
var DEFAULT_OPTIONS = {
  trimmer: (state) => state,
  migrations: [],
  getter: (key) => {
    const persistedState = localStorage.getItem(key);
    return persistedState ? JSON.parse(persistedState) : void 0;
  },
  setter: (key, state) => {
    const serializedState = JSON.stringify(state);
    localStorage.setItem(key, serializedState);
  },
  remover: (key) => {
    localStorage.removeItem(key);
  },
  debounceTime: 100
};
var TinySliceHydrationPlugin = class {
  constructor(localStorageKey, options) {
    __publicField(this, "sink", new Subscription());
    __publicField(this, "options");
    __publicField(this, "hooks");
    __publicField(this, "additionalTriggers", []);
    __publicField(this, "pipeline");
    __publicField(this, "register", (hooks) => {
      var _a, _b;
      this.hooks = hooks;
      const retrievedState = this.retrieve();
      if (retrievedState && (((_b = (_a = this.options).validateRetrieved) == null ? void 0 : _b.call(_a, retrievedState)) ?? true)) {
        this.hooks.stateInjector(retrievedState);
      }
      this.pipeline = this.hooks.state$;
      if (this.options.debounceTime) {
        this.pipeline = this.pipeline.pipe(debounceTime(this.options.debounceTime));
      }
      this.pipeline = this.pipeline.pipe(
        tap((state) => {
          this.persist(state.nextState);
        })
      );
    });
    __publicField(this, "start", () => {
      if (this.pipeline) {
        this.sink.add(this.pipeline.subscribe());
      }
    });
    __publicField(this, "stop", () => {
      this.sink.unsubscribe();
      this.sink = new Subscription();
    });
    __publicField(this, "registerAdditionalTrigger", (trigger) => {
      this.additionalTriggers.push(trigger);
    });
    this.localStorageKey = localStorageKey;
    this.options = {
      ...DEFAULT_OPTIONS,
      ...options
    };
    this.tryMigrations();
  }
  runMigrations() {
    let migrated = false;
    for (const migration of this.options.migrations) {
      const getter = migration.getter ?? this.options.getter;
      const stateToBeMigrated = getter(migration.fromKey);
      if (isNotNullish(stateToBeMigrated)) {
        console.group(
          `${TINYSLICE_PREFIX} Running migration from ${migration.fromKey} to ${migration.toKey}`
        );
        console.log("Migrating", stateToBeMigrated);
        try {
          const stateToBeMigratedTo = getter(migration.toKey);
          if (stateToBeMigratedTo) {
            console.log("Merging...", stateToBeMigratedTo);
          }
          const migratedState = migration.migrate(stateToBeMigrated, stateToBeMigratedTo);
          const setter = migration.setter ?? this.options.setter;
          setter(migration.toKey, migratedState);
          const remover = migration.remover ?? this.options.remover;
          remover(migration.fromKey);
          migrated = true;
          console.log("Migration finished!", migratedState);
        } catch (error) {
          console.error("Migration error!", error);
        }
        console.groupEnd();
      }
    }
    return migrated;
  }
  tryMigrations() {
    let migrated = true;
    while (migrated) {
      migrated = this.runMigrations();
    }
  }
  retrieve() {
    return this.options.getter(this.localStorageKey);
  }
  persist(snapshot) {
    const trimmedState = this.options.trimmer(snapshot);
    this.options.setter(this.localStorageKey, trimmedState);
  }
};
export {
  DEFAULT_OPTIONS,
  TinySliceHydrationPlugin
};
//# sourceMappingURL=@tinyslice_hydration-plugin.js.map
