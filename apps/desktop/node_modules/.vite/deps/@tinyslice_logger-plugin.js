import {
  TINYSLICE_PREFIX,
  isNotNullish
} from "./chunk-STZFUGGS.js";
import "./chunk-NWFPIOKI.js";
import {
  __publicField
} from "./chunk-F3FYYIAV.js";

// ../../node_modules/.pnpm/@tinyslice+logger-plugin@0.8.0/node_modules/@tinyslice/logger-plugin/index.js
var brightFgColor = "#ffe36a";
var dimFgColor = "#f9c33c";
var defaultCss = `background: #222; color: ${brightFgColor};`;
var defaultCssDim = `background: #222; color: ${dimFgColor};`;
var successCss = `background: #090; color: ${brightFgColor};`;
var failCss = `background: #900; color: ${brightFgColor};`;
var normalCss = "background: #222; color: #fff;";
var hiddenCss = "background: #222; color: #444;";
var isSuccessMessage = (message) => message.toLowerCase().includes("success");
var isFailureMessage = (message) => message.toLowerCase().includes("fail");
var isErrorMessage = (message) => message.toLowerCase().includes("error");
var isTinySliceMessage = (message) => message.includes(TINYSLICE_PREFIX);
var getMessageCss = (message, isInternal) => {
  if (isSuccessMessage(message)) {
    return successCss;
  } else if (isFailureMessage(message) || isErrorMessage(message)) {
    return failCss;
  } else {
    return isInternal ? defaultCssDim : defaultCss;
  }
};
var bracketMatcher = /\[[^\]]*]/g;
var separateMessage = (message) => {
  const a = message.split(bracketMatcher);
  const b = message.match(bracketMatcher) ?? [];
  const result = [a[0]];
  for (let i = 1; i < a.length; i++) {
    result.push(b[i - 1], a[i]);
  }
  return result.filter(isNotNullish);
};
var colorizeLogString = (message) => {
  const segments = separateMessage(message);
  const codedSegments = [];
  const colorisedSegments = [];
  const isInternal = segments.some((segment) => isTinySliceMessage(segment));
  for (const segment of segments) {
    const css = getMessageCss(segment, isInternal);
    if (css) {
      codedSegments.push(`%c${segment}`);
      colorisedSegments.push(getMessageCss(segment, isInternal));
    } else {
      codedSegments.push(segment);
      colorisedSegments.push("");
    }
  }
  return ["🍕 " + codedSegments.join(""), ...colorisedSegments];
};
var DEFAULT_OPTIONS = {
  ignorePaths: [],
  ignoreActions: [],
  disableGrouping: false,
  onlyRoot: false,
  onlyTimers: false
};
var TinySliceLoggerPlugin = class {
  constructor(options) {
    __publicField(this, "options");
    __publicField(this, "first", false);
    __publicField(this, "enabled", false);
    __publicField(this, "lastTimer");
    __publicField(this, "pluginOptions", {
      passToChildren: true
    });
    this.options = {
      ...DEFAULT_OPTIONS,
      ...options
    };
  }
  isIgnored(path, actionPacket) {
    return this.options.ignorePaths.some(
      (pathIgnore) => typeof pathIgnore === "string" ? path.startsWith(pathIgnore) || actionPacket.type.startsWith(pathIgnore) : pathIgnore.test(path)
    ) || this.options.ignoreActions.some(
      (actionIgnore) => typeof actionIgnore === "string" ? actionIgnore === actionPacket.type : actionIgnore.test(actionPacket.type)
    );
  }
  sliceOptions() {
    return this.pluginOptions;
  }
  preRootReduce(absolutePath, _state, action) {
    this.first = true;
    if (this.enabled && !this.isIgnored(absolutePath, action)) {
      console.time("entire reduce took");
      if (this.options.disableGrouping) {
        console.log(...colorizeLogString(action.type));
      } else {
        console.groupCollapsed(...colorizeLogString(action.type));
      }
    }
  }
  preReduce(absolutePath, _state, action) {
    if (this.enabled && !this.options.onlyRoot && !this.isIgnored(absolutePath, action)) {
      this.lastTimer = `${absolutePath} reduce took`;
      console.time(this.lastTimer);
    }
  }
  postReduce(absolutePath, snapshot) {
    if (this.enabled && !this.options.onlyRoot && !this.isIgnored(absolutePath, snapshot.actionPacket)) {
      const changed = snapshot.prevState !== snapshot.nextState;
      const logCss = changed ? normalCss : hiddenCss;
      if (!this.options.onlyTimers) {
        if (this.options.disableGrouping) {
          console.log(`%c${absolutePath}`, logCss);
        } else {
          if (this.first) {
            this.first = false;
            console.group(`%c${absolutePath}`, logCss);
          } else {
            console.groupCollapsed(`%c${absolutePath}`, logCss);
          }
        }
        console.info("%cprevState", logCss, snapshot.prevState);
        console.info("%cpayload", logCss, snapshot.actionPacket.payload);
        console.info("%cnextState", logCss, snapshot.nextState);
      }
      console.timeEnd(`${absolutePath} reduce took`);
      if (!this.options.onlyTimers && !this.options.disableGrouping) {
        console.groupEnd();
      }
    }
  }
  postRootReduce(absolutePath, snapshot) {
    if (this.enabled && !this.isIgnored(absolutePath, snapshot.actionPacket)) {
      console.timeEnd("entire reduce took");
      if (!this.options.disableGrouping) {
        console.groupEnd();
      }
    }
  }
  start() {
    this.enabled = true;
    return void 0;
  }
  stop() {
    if (!this.options.disableGrouping) {
      if (this.lastTimer) {
        console.timeEnd(this.lastTimer);
      }
      console.groupEnd();
    }
    this.enabled = false;
    return void 0;
  }
  register(_hooks) {
    return void 0;
  }
};
export {
  DEFAULT_OPTIONS,
  TinySliceLoggerPlugin,
  colorizeLogString
};
//# sourceMappingURL=@tinyslice_logger-plugin.js.map
