import {
  BehaviorSubject,
  EMPTY,
  NEVER,
  Observable,
  Subject,
  Subscription,
  asapScheduler,
  asyncScheduler,
  catchError,
  combineLatest,
  distinctUntilChanged,
  filter,
  finalize,
  firstValueFrom,
  map,
  of,
  pairwise,
  scheduled,
  share,
  shareReplay,
  skip,
  startWith,
  switchMap,
  take,
  takeWhile,
  tap,
  throttleTime,
  withLatestFrom,
  zip
} from "./chunk-NWFPIOKI.js";
import {
  __publicField
} from "./chunk-F3FYYIAV.js";

// ../../node_modules/.pnpm/@alexaegis+common@0.4.5/node_modules/@alexaegis/common/index.js
var DEFAULT_ES_TARGET_YEAR = 2022;
var DEFAULT_ES_TARGET_NAME = `es${DEFAULT_ES_TARGET_YEAR}`;
var isNotNullish = (o) => o !== void 0 && o !== null;

// ../../node_modules/.pnpm/@tinyslice+core@0.8.0/node_modules/@tinyslice/core/index.js
var DEFAULT_ACTION_CONFIG = {
  throttleTime: void 0
};
var isActionPacket = (actionPacket, registeredInActionMap) => {
  return actionPacket !== void 0 && isNotNullish(actionPacket.type) && ((registeredInActionMap == null ? void 0 : registeredInActionMap.has(actionPacket.type)) ?? true);
};
var includesArrayComparator = (prev, next) => prev.every((slice) => next.includes(slice));
var fastArrayComparator = (prev, next) => {
  if (prev.length !== next.length) {
    return false;
  } else if (next.length === 0) {
    return true;
  } else {
    for (let i = 0; i <= next.length; i++) {
      if (prev[i] !== next[i]) {
        return false;
      }
    }
    return true;
  }
};
var TINYSLICE_PREFIX = "[TinySlice]";
var TINYSLICE_INTERNAL_PREFIX = `${TINYSLICE_PREFIX} [Internal]`;
var TINYSLICE_DEFAULT_PREFIX = `${TINYSLICE_PREFIX} [Default]`;
var entitySliceReducerWithPrecompute = (precompute, entityReducer) => {
  return (state, payload) => {
    const precomputed = precompute(state, payload);
    return Object.entries(state).reduce(
      (acc, [key, tile]) => {
        acc[key] = entityReducer(key, tile, payload, precomputed) ?? tile;
        return acc;
      },
      // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
      {}
    );
  };
};
var entitySliceReducer = (entityReducer) => {
  return (state, payload) => Object.entries(state).reduce(
    (acc, [key, tile]) => {
      acc[key] = entityReducer(key, tile, payload) ?? tile;
      return acc;
    },
    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter
    {}
  );
};
var hasKey = (parent, key) => {
  return isNotNullish(key) && isNotNullish(parent) && typeof parent === "object" && Object.hasOwn(parent, key);
};
function ifLatestFrom(input, condition) {
  return (source) => {
    return source.pipe(
      withLatestFrom(input),
      filter(([sourceResult, inputResult]) => condition(inputResult, sourceResult)),
      map(([a]) => a)
    );
  };
}
var getObjectKeys = (state) => Object.keys(state);
var getObjectKeysAsNumbers = (state) => Object.keys(state).map((key) => Number.parseInt(key, 10));
var getNextNumberLikeStringKey = (keys) => (keys.map((key) => Number.parseInt(key, 10)).reduce((a, b) => a > b ? a : b, 0) + 1).toString();
var getNextLargestNumber = (keys) => keys.reduce((a, b) => a > b ? a : b, 0) + 1;
var getNextSmallestNumber = (keys) => {
  const sortedKeys = [...keys].sort((a, b) => a - b);
  for (let i = 0; i < sortedKeys.length; i++) {
    if (!sortedKeys.includes(i + 1)) {
      return i + 1;
    }
  }
  return (sortedKeys.at(-1) ?? 0) + 1;
};
var PremadeGetNext = ((PremadeGetNext2) => {
  PremadeGetNext2["nextLargest"] = "nextlargest";
  PremadeGetNext2["nextSmallest"] = "nextsmallest";
  return PremadeGetNext2;
})(PremadeGetNext || {});
var getNextKeyStrategy = (nextKeyStrategy) => {
  if (typeof nextKeyStrategy === "function") {
    return nextKeyStrategy;
  } else if (nextKeyStrategy === "nextlargest") {
    return getNextLargestNumber;
  } else if (nextKeyStrategy === "nextsmallest") {
    return getNextSmallestNumber;
  } else {
    return getNextLargestNumber;
  }
};
var isNonNullable = (o) => o !== void 0 && o !== null;
var isNullish = (o) => o === void 0 || o === null;
var updateObject = (base, other) => {
  if (other !== void 0 && other !== null) {
    if (typeof base === "object") {
      if (Array.isArray(base)) {
        const copy = [...base];
        for (const [key, value] of other.entries()) {
          if (value !== void 0) {
            copy[key] = value;
          }
        }
        return copy;
      } else {
        return { ...base, ...other };
      }
    } else {
      return other;
    }
  } else {
    return base;
  }
};
var Action = class extends Subject {
  //	override subscribe;
  /**
   * TODO: Make this private, refactor angular solution
   * @param type
   * @param config
   */
  constructor(type, config = DEFAULT_ACTION_CONFIG) {
    super();
    __publicField(this, "dispatchSubscription");
    __publicField(this, "config");
    __publicField(this, "scope");
    __publicField(this, "registrations", new Subscription());
    __publicField(this, "actionPipeline");
    this.type = type;
    this.config = {
      ...DEFAULT_ACTION_CONFIG,
      ...config
    };
    this.actionPipeline = this;
    if (isNotNullish(this.config.pauseWhile)) {
      this.actionPipeline = this.actionPipeline.pipe(
        ifLatestFrom(this.config.pauseWhile, (paused) => !paused)
      );
    }
    if (isNotNullish(this.config.throttleTime)) {
      this.actionPipeline = this.actionPipeline.pipe(
        throttleTime(this.config.throttleTime, asyncScheduler, {
          leading: true,
          trailing: true
        })
      );
    }
  }
  /**
   * This will emit every action of this type, both direct dispatches and
   * effect dispatches
   */
  get listenPackets$() {
    var _a;
    return ((_a = this.scope) == null ? void 0 : _a.listen$(this)) ?? EMPTY;
  }
  /**
   * This won't receive actions from effects
   */
  get listen$() {
    return this.actionPipeline;
  }
  register(scope) {
    this.scope = scope;
    this.dispatchSubscription = this.scope.registerAction(this, true);
    return this;
  }
  unregister() {
    var _a;
    (_a = this.dispatchSubscription) == null ? void 0 : _a.unsubscribe();
  }
  makePacket(payload) {
    return { type: this.type, payload };
  }
  /**
   * The finalize operator will take care of removing it from the actionMap
   */
  complete() {
    this.unregister();
    this.registrations.unsubscribe();
    this.unsubscribe();
  }
  /**
   *
   */
  getFilter() {
    return (source) => source.pipe(filter((value) => value.type === this.type));
  }
  static makeFilter(...actions) {
    const allowedTypes = new Set(actions.map((action) => action.type));
    return (source) => source.pipe(filter((value) => allowedTypes.has(value.type)));
  }
  reduce(actionReducer) {
    return {
      packetReducer: (state, actionPacket) => actionPacket ? actionReducer(state, actionPacket.payload) : state,
      action: this
    };
  }
};
var isReduceActionSliceSnapshot = (t) => isNotNullish(t.actionPacket);
var extractSliceOptions = (constructOptions) => {
  return {
    defineInternals: constructOptions == null ? void 0 : constructOptions.defineInternals,
    metaReducers: constructOptions == null ? void 0 : constructOptions.metaReducers,
    plugins: constructOptions == null ? void 0 : constructOptions.plugins,
    reducers: constructOptions == null ? void 0 : constructOptions.reducers
  };
};
var normalizeSliceDirection = (sliceDirection) => {
  if (typeof sliceDirection === "object") {
    return sliceDirection;
  } else {
    const key = sliceDirection;
    const selector = (state) => {
      return isNotNullish(state) && typeof state === "object" ? state[key] : void 0;
    };
    const merger = (parentState, state) => {
      if (isNullish(parentState)) {
        return parentState;
      }
      return typeof parentState === "object" ? {
        ...parentState,
        [key]: state
      } : parentState;
    };
    return {
      merger,
      selector
    };
  }
};
var Slice = class _Slice extends Observable {
  /**
   *
   * @param initialState
   * @param sliceSegment a string that represents this slice, has to be
   * unique on it's parent.
   */
  constructor(options) {
    var _a, _b, _c;
    super();
    __publicField(this, "sink", new Subscription());
    __publicField(this, "options");
    __publicField(this, "scope");
    __publicField(this, "initialState");
    __publicField(this, "parentCoupling");
    __publicField(this, "initialReducers");
    __publicField(this, "initialPlugins");
    __publicField(this, "state$");
    __publicField(this, "_pathSegment");
    __publicField(this, "_absolutePath");
    __publicField(this, "setAction");
    __publicField(this, "updateAction");
    __publicField(this, "deleteKeyAction");
    __publicField(this, "defineKeyAction");
    __publicField(this, "observableState$");
    __publicField(this, "defaultReducerConfigurations");
    __publicField(this, "reducerConfigurations$");
    __publicField(this, "autoRegisterReducerActions$");
    __publicField(this, "downStreamReducers$");
    __publicField(this, "sliceReducer$");
    __publicField(this, "sliceReducingActions$");
    __publicField(this, "plugins$");
    __publicField(this, "autoRegisterPlugins$");
    __publicField(this, "nullishParentPause$");
    __publicField(this, "manualPause$");
    __publicField(this, "pause$");
    __publicField(this, "keyedSlices$", new BehaviorSubject({}));
    __publicField(this, "slices$", this.keyedSlices$.pipe(map((keyedSlices) => Object.values(keyedSlices))));
    __publicField(this, "subscribe");
    // Listens to the parent for changes to select itself from
    // check if the parent could do it instead
    __publicField(this, "parentListener");
    __publicField(this, "inactivePipeline");
    __publicField(this, "activePipeline");
    __publicField(this, "pipeline");
    __publicField(this, "defineInternals");
    __publicField(this, "_internals");
    __publicField(this, "scopedActions", []);
    this.options = options;
    this.scope = options.scope;
    this._pathSegment = options.pathSegment;
    this.initialState = options.initialState;
    this.parentCoupling = options.parentCoupling;
    this.initialReducers = options.reducers ?? [];
    this.initialPlugins = options.plugins ?? [];
    this.defineInternals = options.defineInternals;
    this.nullishParentPause$ = new BehaviorSubject(false);
    this.manualPause$ = new BehaviorSubject(false);
    this.pause$ = combineLatest([this.nullishParentPause$, this.manualPause$]).pipe(
      map(([nullishParentPause, manualPause]) => nullishParentPause || manualPause)
    );
    this._absolutePath = _Slice.calculateAbsolutePath(this.parentCoupling, this._pathSegment);
    this.setAction = this.createAction(`${TINYSLICE_DEFAULT_PREFIX} set`);
    this.updateAction = this.createAction(`${TINYSLICE_DEFAULT_PREFIX} update`);
    this.deleteKeyAction = this.createAction(
      `${TINYSLICE_DEFAULT_PREFIX} delete key`
    );
    this.defineKeyAction = this.createAction(
      `${TINYSLICE_DEFAULT_PREFIX} define key`
    );
    this.state$ = new BehaviorSubject(this.initialState);
    this.observableState$ = this.state$.pipe(distinctUntilChanged());
    this.defaultReducerConfigurations = [
      this.setAction.reduce((_state, payload) => payload),
      this.updateAction.reduce((state, payload) => updateObject(state, payload)),
      this.deleteKeyAction.reduce((state, payload) => {
        if (typeof state === "object") {
          const nextState = { ...state };
          delete nextState[payload];
          return nextState;
        } else {
          return state;
        }
      }),
      this.defineKeyAction.reduce((state, payload) => {
        return typeof state === "object" ? {
          ...state,
          [payload.key]: payload.data
        } : state;
      })
    ];
    this.reducerConfigurations$ = new BehaviorSubject([
      ...this.defaultReducerConfigurations,
      ...this.initialReducers
    ]);
    this.autoRegisterReducerActions$ = this.reducerConfigurations$.pipe(
      tap((reducerConfigurations) => {
        for (const reducerConfiguration of reducerConfigurations) {
          this.scope.registerAction(reducerConfiguration.action);
        }
      })
    );
    this.sliceReducer$ = this.reducerConfigurations$.pipe(
      map(
        (reducerConfigurations) => (state, action) => action ? reducerConfigurations.filter((rc) => rc.action.type === action.type).reduce(
          (acc, { packetReducer }) => packetReducer(acc, action),
          state
        ) : state
      ),
      shareReplay(1)
    );
    this.sliceReducingActions$ = this.reducerConfigurations$.pipe(
      map((reducerConfigurations) => [
        ...new Set(reducerConfigurations.map((r) => r.action.type))
      ]),
      shareReplay(1)
    );
    this.downStreamReducers$ = this.slices$.pipe(
      withLatestFrom(this.sliceReducingActions$),
      switchMap(([slices, sliceReducingActions]) => {
        return slices.length > 0 ? combineLatest(slices.map((next) => next.slice.downStreamReducers$)).pipe(
          map((subSliceReducer) => [
            ...sliceReducingActions,
            ...subSliceReducer.flat()
          ])
        ) : of(sliceReducingActions);
      }),
      shareReplay(1)
      // computed from a behaviorSubject and another computed field
    );
    const slicesWithDownStreamReducers$ = this.slices$.pipe(
      switchMap((sliceRegistrations) => {
        return sliceRegistrations.length > 0 ? combineLatest(
          sliceRegistrations.map(
            (sliceRegistration) => sliceRegistration.slice.downStreamReducers$.pipe(
              map((downStreamReducers) => ({
                downStreamReducers,
                sliceRegistration
              }))
            )
          )
        ) : of([]);
      }),
      shareReplay(1)
      // computed from behaviorSubjects from a behaviorSubject
    );
    const schedulingDispatcher$ = this.scope.schedulingDispatcher$.pipe(
      ifLatestFrom(
        this.downStreamReducers$,
        (downStreamReducers, actionPacket) => downStreamReducers.includes(actionPacket.type)
      ),
      tap((actionPacket) => {
        this.executeMetaPreReducers(actionPacket);
      })
    );
    const dispatchAndSlices$ = schedulingDispatcher$.pipe(
      switchMap(
        (actionPacket) => slicesWithDownStreamReducers$.pipe(
          take(1),
          map((slicesWithDownStreamReducers) => ({
            actionPacket,
            slicesWithDownStreamReducers
          }))
        )
      )
    );
    const filterSliceRegistrationBasedOnActionTypeSupport = (slicesWithDownStreamReducers, actionType) => {
      return slicesWithDownStreamReducers.map(({ sliceRegistration, downStreamReducers }) => {
        return downStreamReducers.includes(actionType) ? sliceRegistration.slice.pipeline.pipe(
          map(
            (snapshot) => ({
              snapshot,
              sliceRegistration
            })
          )
        ) : void 0;
      }).filter(isNotNullish);
    };
    const zippedDispatch = dispatchAndSlices$.pipe(
      switchMap(({ slicesWithDownStreamReducers, actionPacket }) => {
        const neededChildSlices = filterSliceRegistrationBasedOnActionTypeSupport(
          slicesWithDownStreamReducers,
          actionPacket.type
        );
        return neededChildSlices.length > 0 ? zip(neededChildSlices).pipe(
          map((sliceChanges) => ({ sliceChanges, actionPacket }))
        ) : of({ sliceChanges: [], actionPacket });
      })
    );
    this.activePipeline = zippedDispatch.pipe(
      withLatestFrom(this.state$, this.sliceReducer$),
      map(
        ([
          { actionPacket, sliceChanges },
          prevState,
          sliceReducer
        ]) => {
          if (this.isRootOrParentStateUndefined()) {
            return {
              actionPacket,
              prevState,
              nextState: prevState
            };
          }
          const nextState = sliceChanges.filter(
            (sliceChange) => sliceChange.snapshot.prevState !== sliceChange.snapshot.nextState
          ).reduce(
            (prevState2, sliceChange) => sliceChange.sliceRegistration.slicer.merger(
              prevState2,
              sliceChange.snapshot.nextState
            ),
            prevState
          ) ?? prevState;
          return {
            actionPacket,
            prevState,
            nextState: sliceReducer(nextState, actionPacket)
          };
        }
      ),
      tap((snapshot) => {
        if (snapshot.prevState !== snapshot.nextState) {
          this.state$.next(snapshot.nextState);
        }
      }),
      catchError((error, pipeline$) => {
        console.error(`${TINYSLICE_PREFIX} slice pipeline error 
`, error);
        return this.plugins$.pipe(
          take(1),
          tap((plugins) => {
            var _a2;
            for (const plugin of plugins) {
              (_a2 = plugin.onError) == null ? void 0 : _a2.call(plugin, error);
            }
          }),
          switchMap(() => pipeline$)
        );
      })
    );
    this.inactivePipeline = schedulingDispatcher$.pipe(
      withLatestFrom(this.state$),
      map(([, state]) => {
        return {
          actionPacket: { type: "paused", payload: void 0 },
          prevState: state,
          nextState: state
        };
      })
    );
    this.pipeline = this.pause$.pipe(
      switchMap((paused) => paused ? this.inactivePipeline : this.activePipeline),
      tap((snapshot) => {
        this.executeMetaPostReducers(snapshot);
      }),
      share()
      // has to be shared because of child listeners
    );
    this.plugins$ = new BehaviorSubject(this.initialPlugins);
    this.parentListener = (_a = this.parentCoupling) == null ? void 0 : _a.rawParentState.pipe(
      skip(1),
      finalize(() => {
        this.complete();
      }),
      takeWhile(
        (parentState) => {
          var _a2;
          return ((_a2 = this.parentCoupling) == null ? void 0 : _a2.droppable) ? hasKey(parentState, this.parentCoupling.key) : true;
        }
      ),
      tap((parentState) => {
        if (isNullish(parentState) && !this.nullishParentPause$.value) {
          this.nullishParentPause$.next(true);
        } else if (this.nullishParentPause$.value) {
          this.nullishParentPause$.next(false);
        }
      }),
      filter(isNotNullish),
      map((parentState) => {
        var _a2;
        return (_a2 = this.parentCoupling) == null ? void 0 : _a2.slicer.selector(parentState);
      }),
      distinctUntilChanged(),
      tap((stateFromParent) => {
        this.state$.next(stateFromParent);
      })
    );
    this.autoRegisterPlugins$ = this.plugins$.pipe(
      startWith([]),
      pairwise(),
      tap(([previous, next]) => {
        for (const plugin of previous.filter((plugin2) => !next.includes(plugin2))) {
          plugin.stop();
        }
        for (const plugin of next.filter((plugin2) => !previous.includes(plugin2))) {
          this.registerPlugin(plugin);
        }
      })
    );
    this.subscribe = this.observableState$.pipe(filter(isNotNullish)).subscribe.bind(this.observableState$);
    this.scope.slices.set(this._absolutePath, this);
    if (this.parentCoupling) {
      this.parentCoupling.parentSlice.registerSlice({
        slice: this,
        slicer: this.parentCoupling.slicer,
        initialState: this.initialState,
        key: this.parentCoupling.key
      });
      this.sink.add((_b = this.parentListener) == null ? void 0 : _b.subscribe());
    }
    this.sink.add(this.autoRegisterReducerActions$.subscribe());
    this.sink.add(this.autoRegisterPlugins$.subscribe());
    this.sink.add(this.pipeline.subscribe());
    this._internals = ((_c = this.defineInternals) == null ? void 0 : _c.call(this, this)) ?? {};
  }
  get internals() {
    return this._internals;
  }
  get absolutePath() {
    return this._absolutePath;
  }
  get pathSegment() {
    return this._pathSegment;
  }
  /**
   * For debugging purposes
   */
  printSliceStructure(indentationLevel = 0) {
    if (indentationLevel === 0) {
      console.groupCollapsed("Slice Structure", this.absolutePath);
    }
    console.log("	".repeat(indentationLevel) + this.pathSegment);
    for (const [, value] of Object.entries(this.keyedSlices$.value)) {
      value.slice.printSliceStructure(indentationLevel + 1);
    }
    if (indentationLevel === 0) {
      console.groupEnd();
    }
  }
  executeMetaPreReducers(action) {
    var _a, _b;
    for (const plugin of this.plugins$.value) {
      if (!this.options.parentCoupling) {
        (_a = plugin.preRootReduce) == null ? void 0 : _a.call(plugin, this._absolutePath, this.state$.value, action);
      }
      (_b = plugin.preReduce) == null ? void 0 : _b.call(plugin, this._absolutePath, this.state$.value, action);
    }
  }
  executeMetaPostReducers(snapshot) {
    var _a, _b;
    for (const plugin of this.plugins$.value) {
      (_a = plugin.postReduce) == null ? void 0 : _a.call(plugin, this._absolutePath, snapshot);
      if (!this.options.parentCoupling) {
        (_b = plugin.postRootReduce) == null ? void 0 : _b.call(plugin, this._absolutePath, snapshot);
      }
    }
  }
  loadAndSetPlugins(...pluginImports) {
    return Promise.all(pluginImports.map((pluginImport) => pluginImport())).then((plugins) => {
      this.setPlugins(plugins);
      return plugins;
    });
  }
  get paused$() {
    return this.pause$;
  }
  /**
   * Unpauses this slice and every child slice recursively
   */
  unpause() {
    if (this.manualPause$.value) {
      this.manualPause$.next(false);
    }
    for (const subSlice of Object.values(this.keyedSlices$.value)) {
      subSlice.slice.unpause();
    }
  }
  /**
   * Pauses this slice and every child slice recursively
   */
  pause() {
    if (!this.manualPause$.value) {
      this.manualPause$.next(true);
    }
    for (const subSlice of Object.values(this.keyedSlices$.value)) {
      subSlice.slice.pause();
    }
  }
  /**
   * Effects created here will respond to the pause and unpauseEffects functions.
   * These effects will also unsubscribe if the slice unsubscribes
   */
  createEffect(packet$) {
    const pausablePacket$ = this.paused$.pipe(
      switchMap((isPaused) => isPaused ? NEVER : packet$)
    );
    const effectSubscription = this.scope.createEffect(pausablePacket$);
    this.sink.add(effectSubscription);
    return effectSubscription;
  }
  setPlugins(plugins) {
    this.plugins$.next([...this.options.plugins ?? [], ...plugins]);
  }
  getPlugins() {
    return this.plugins$.value;
  }
  addPlugin(...plugins) {
    this.plugins$.next([...this.plugins$.value, ...plugins]);
  }
  getReducers() {
    return this.reducerConfigurations$.value;
  }
  /**
   * This does not disable default redurces.
   */
  setReducers(reducers) {
    this.reducerConfigurations$.next([...this.defaultReducerConfigurations, ...reducers]);
  }
  addReducers(reducers) {
    this.reducerConfigurations$.next([...this.reducerConfigurations$.value, ...reducers]);
  }
  static assembleAbsolutePath(parentAbsolutePath, segment) {
    return `${parentAbsolutePath}${parentAbsolutePath ? "." : ""}${segment}`;
  }
  static calculateAbsolutePath(parentCoupling, pathSegment) {
    return parentCoupling ? _Slice.assembleAbsolutePath(parentCoupling.parentSlice._absolutePath, pathSegment) : pathSegment;
  }
  registerPlugin(plugin) {
    plugin.register({
      initialState: this.state$.value,
      state$: this.pipeline,
      stateInjector: (state) => {
        this.state$.next(state);
      }
    });
    plugin.start();
    return plugin;
  }
  set(slice) {
    this.setAction.next(slice);
  }
  update(slice) {
    this.updateAction.next(slice);
  }
  set value(value) {
    this.set(value);
  }
  get value() {
    return this.state$.value;
  }
  isRootOrParentStateUndefined() {
    return this.parentCoupling ? isNullish(this.parentCoupling.parentSlice.state$.value) : false;
  }
  static createRootSlice(scope, initialState, sliceOptions) {
    return new _Slice({
      ...extractSliceOptions(sliceOptions),
      scope,
      initialState,
      pathSegment: "root"
    });
  }
  createAction(name, actionOptions) {
    const actionName = `${this._absolutePath} ${name}`;
    const action = this.scope.createAction(actionName, {
      ...actionOptions,
      pauseWhile: this.paused$
    });
    this.scopedActions.push(action);
    return action;
  }
  sliceInternal(childSliceConstructOptions) {
    const path = _Slice.assembleAbsolutePath(
      this._absolutePath,
      childSliceConstructOptions.pathSegment.toString()
    );
    if (this.scope.slices.has(path)) {
      return this.scope.slices.get(path);
    } else {
      const initialStateFromParent = this.state$.value ? childSliceConstructOptions.slicer.selector(this.state$.value) : void 0;
      const initialState = initialStateFromParent ?? childSliceConstructOptions.initialState;
      return new _Slice({
        ...extractSliceOptions(childSliceConstructOptions),
        plugins: [
          ...this.plugins$.value.filter(
            (plugin) => {
              var _a, _b;
              return ((_b = (_a = plugin.sliceOptions) == null ? void 0 : _a.call(plugin)) == null ? void 0 : _b.passToChildren) ?? false;
            }
          ),
          ...childSliceConstructOptions.plugins ?? []
        ],
        scope: this.scope,
        initialState,
        parentCoupling: {
          parentSlice: this,
          rawParentState: this.observableState$,
          slicer: childSliceConstructOptions.slicer,
          droppable: childSliceConstructOptions.droppable,
          key: childSliceConstructOptions.key
        },
        pathSegment: childSliceConstructOptions.pathSegment
      });
    }
  }
  /**
   * @deprecated remove this, too much trouble because of selector.toString(), use dice instead
   */
  sliceSelect(selector, merger, sliceOptions) {
    return this.sliceInternal({
      ...sliceOptions,
      initialState: void 0,
      droppable: false,
      slicer: {
        selector,
        merger
      },
      key: void 0,
      pathSegment: selector.toString()
    });
  }
  slice(key, sliceOptions) {
    const slicer = normalizeSliceDirection(key);
    return this.sliceInternal({
      ...sliceOptions,
      pathSegment: key.toString(),
      slicer,
      key,
      droppable: false
    });
  }
  /**
   * Adds non-defined "lazy" slices to extend this slice
   * ? https://github.com/microsoft/TypeScript/issues/42315
   * ? key could be restricted to disallow keys of Slice once negated types
   * ? are implemented in TypeScript
   */
  addSlice(key, initialState, sliceOptions) {
    const slicer = normalizeSliceDirection(key);
    return this.sliceInternal({
      ...sliceOptions,
      initialState,
      pathSegment: key.toString(),
      slicer,
      key,
      droppable: false
    });
  }
  /**
   * Adds a new lazy slice then dices it with a number type record,
   * you can choose between nextKeyStrategies:
   * - NEXT_SMALLEST
   * - NEXT_LARGEST,
   * - CUSTOM
   *
   * NEXT_LARGEST is the default as thats the simplest.
   *
   * ! make sure key doesn't exist via generics on State once that can be done in TS
   */
  addDicedSlice(key, initialState, diceConstructOptions) {
    return this.addSlice(key, {}, diceConstructOptions.dicedSliceOptions).dice(
      initialState,
      {
        ...diceConstructOptions,
        getAllKeys: getObjectKeysAsNumbers,
        getNextKey: getNextKeyStrategy(diceConstructOptions.getNextKeyStrategy)
      }
    );
  }
  /**
   * This slice type is created on the fly for N subsclices of the same type
   * great for complex entities that spawn on the fly and have their own
   * state definition.
   *
   * This defines two layers of state at once. The middle layer stores the bottom layers
   * you can ask for bottom layers lazyly using a selector. You'll then receive the
   * slice object and, all the other guts you predefined, like state observers, actions, etc
   *
   * Actions are automatically scoped to these selected subslices
   *
   * Nomenclature: Slicing means to take a single piece of state, dicing is multiple
   */
  dice(initialState, diceConstructOptions) {
    const sliceOptions = extractSliceOptions(diceConstructOptions);
    const get = (key) => {
      const slicer = normalizeSliceDirection(key);
      return this.sliceInternal({
        ...sliceOptions,
        initialState,
        pathSegment: key.toString(),
        slicer,
        key,
        droppable: true
      });
    };
    const has = (key) => this.state$.value && typeof this.state$.value === "object" ? Object.keys(this.state$.value).includes(key) : false;
    const set = (key, data) => {
      this.defineKeyAction.next({ key, data });
    };
    const remove = (key) => {
      this.deleteKeyAction.next(key);
    };
    const keys = () => diceConstructOptions.getAllKeys(this.value);
    const getNextKey = () => diceConstructOptions.getNextKey(keys());
    const add = (data) => {
      this.defineKeyAction.next({ key: getNextKey(), data });
    };
    const create = () => {
      this.defineKeyAction.next({ key: getNextKey(), data: void 0 });
    };
    const keys$ = this.pipe(
      map((state) => diceConstructOptions.getAllKeys(state)),
      distinctUntilChanged(fastArrayComparator)
    );
    const items$ = keys$.pipe(
      map((keys2) => keys2.map((key) => get(key))),
      switchMap((slices) => slices.length > 0 ? combineLatest(slices) : of([]))
    );
    const count$ = keys$.pipe(map((keys2) => keys2.length));
    const some$ = (predicate) => items$.pipe(map((items) => items.some(predicate)));
    const every$ = (predicate) => items$.pipe(map((items) => items.every(predicate)));
    const selectOnceDefined = (key) => firstValueFrom(
      keys$.pipe(
        filter((keys2) => keys2.includes(key)),
        map(
          () => this.slice(
            key,
            sliceOptions
          )
        )
      )
    );
    return {
      slice: this,
      selectOnceDefined,
      has,
      get,
      keys,
      keys$,
      count$,
      items$,
      some$,
      every$,
      add,
      set,
      remove,
      create,
      getNextKey
    };
  }
  registerSlice(sliceRegistration) {
    this.keyedSlices$.next({
      ...this.keyedSlices$.value,
      [sliceRegistration.slice._pathSegment]: sliceRegistration
    });
    if (!hasKey(this.value, sliceRegistration.key) || sliceRegistration.initialState !== sliceRegistration.slicer.selector(this.value)) {
      this.setAction.next(
        sliceRegistration.slicer.merger(
          this.value,
          sliceRegistration.initialState
        )
      );
    }
  }
  /**
   *
   * @param pathSegment single segment, not the entire absolutePath
   */
  unregisterSlice(pathSegment) {
    const nextSlicesSet = {
      ...this.keyedSlices$.value
    };
    delete nextSlicesSet[pathSegment];
    this.keyedSlices$.next(nextSlicesSet);
  }
  /**
   * Tears down itself and anything below
   */
  complete() {
    var _a;
    this.manualPause$.complete();
    this.state$.complete();
    this.keyedSlices$.complete();
    this.plugins$.complete();
    this.reducerConfigurations$.complete();
    (_a = this.parentCoupling) == null ? void 0 : _a.parentSlice.unregisterSlice(this.pathSegment);
    for (const scopedAction of this.scopedActions) {
      scopedAction.complete();
    }
    this.scope.slices.delete(this._absolutePath);
    this.sink.unsubscribe();
  }
  asObservable() {
    return this.pipe();
  }
};
var Scope = class {
  constructor() {
    __publicField(this, "schedulingDispatcher");
    __publicField(this, "actionMap", /* @__PURE__ */ new Map());
    __publicField(this, "schedulingDispatcher$");
    __publicField(this, "effectSubscriptions");
    __publicField(this, "stores");
    __publicField(this, "slices");
    this.schedulingDispatcher = new Subject();
    this.schedulingDispatcher$ = this.schedulingDispatcher.asObservable();
    this.actionMap = /* @__PURE__ */ new Map();
    this.effectSubscriptions = new Subscription();
    this.stores = [];
    this.slices = /* @__PURE__ */ new Map();
  }
  createAction(type, config) {
    return this.actionMap.has(type) ? this.actionMap.get(type) : new Action(type, config).register(this);
  }
  createRootSlice(initialState, rootSliceOptions) {
    return Slice.createRootSlice(this, initialState, rootSliceOptions);
  }
  /**
   * Using this ensures packets returned by effects are reduced on next tick.
   * Otherwise the normal reducer could overwrite whatever the effect
   * is producing.
   * Let's say you'd write a typical useless machine, if the effect notices
   * you set a boolean state to true, it sets it back to false immediately.
   * Without this scheduling, the effects result could happen before the
   * triggering actions reduce and the state would be left as true.
   */
  createEffect(action) {
    const source = scheduled(action, asapScheduler).pipe(
      tap((packet) => {
        if (isActionPacket(packet, this.actionMap)) {
          this.schedulingDispatcher.next(packet);
        }
      }),
      catchError((error, pipeline$) => {
        console.error(
          `%c${TINYSLICE_PREFIX} error in effect!
`,
          "background: #222, color: #e00;",
          error
        );
        return pipeline$;
      })
    );
    const effectSubscription = source.subscribe();
    this.effectSubscriptions.add(effectSubscription);
    return effectSubscription;
  }
  /**
   * Only used for cleanup
   */
  registerRootSlice(store) {
    this.stores.push(store);
  }
  registerAction(action, registerFromAction = false) {
    if (this.actionMap.has(action.type)) {
      return;
    }
    this.actionMap.set(action.type, action);
    const subscription = action.listen$.pipe(
      map((payload) => action.makePacket(payload)),
      finalize(() => this.actionMap.delete(action.type)),
      tap((next) => {
        this.schedulingDispatcher.next(next);
      })
    ).subscribe();
    action.registrations.add(subscription);
    if (!registerFromAction) {
      action.register(this);
    }
    return subscription;
  }
  listen$(...actions) {
    return this.schedulingDispatcher.pipe(Action.makeFilter(...actions));
  }
  listenAll$() {
    return this.schedulingDispatcher.asObservable();
  }
  isRegistered(action) {
    if (!action) {
      return false;
    }
    const type = typeof action === "string" ? action : action.type;
    return this.actionMap.has(type);
  }
  get closed() {
    return this.schedulingDispatcher.closed;
  }
  complete() {
    for (const [, action] of this.actionMap) {
      action.complete();
    }
    this.actionMap.clear();
    this.effectSubscriptions.unsubscribe();
    this.schedulingDispatcher.complete();
    for (const store of this.stores) {
      store.complete();
    }
  }
};

export {
  isNotNullish,
  DEFAULT_ACTION_CONFIG,
  isActionPacket,
  includesArrayComparator,
  fastArrayComparator,
  TINYSLICE_PREFIX,
  TINYSLICE_INTERNAL_PREFIX,
  TINYSLICE_DEFAULT_PREFIX,
  entitySliceReducerWithPrecompute,
  entitySliceReducer,
  hasKey,
  ifLatestFrom,
  getObjectKeys,
  getObjectKeysAsNumbers,
  getNextNumberLikeStringKey,
  getNextLargestNumber,
  getNextSmallestNumber,
  PremadeGetNext,
  getNextKeyStrategy,
  isNonNullable,
  isNullish,
  updateObject,
  Action,
  isReduceActionSliceSnapshot,
  normalizeSliceDirection,
  Slice,
  Scope
};
//# sourceMappingURL=chunk-STZFUGGS.js.map
