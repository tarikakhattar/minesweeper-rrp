{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/@alexaegis+common@0.4.5/node_modules/@alexaegis/common/index.js", "../../../../../node_modules/.pnpm/@tinyslice+core@0.8.0/node_modules/@tinyslice/core/index.js"],
  "sourcesContent": ["const isPromiseFulfilled = (promiseResult) => {\n  return promiseResult.status === \"fulfilled\";\n};\nconst asyncFilterMap = async (array, map) => {\n  const checks = await Promise.allSettled(array.map(map));\n  return checks.filter(isPromiseFulfilled).map((item) => item.value).filter(isNotNullish);\n};\nconst filterMark = {};\nconst asyncFilter = async (array, predicate) => {\n  const checks = await Promise.allSettled(\n    array.map((item, i) => {\n      return predicate(item, i).then((result) => result ? item : filterMark);\n    })\n  );\n  return checks.filter(isPromiseFulfilled).map((item) => item.value).filter((result) => result !== filterMark);\n};\nconst asyncMap = async (array, map) => {\n  return Promise.all(array.map(map));\n};\nconst DEFAULT_ES_TARGET_YEAR = 2022;\nconst DEFAULT_ES_TARGET_NAME = `es${DEFAULT_ES_TARGET_YEAR}`;\nconst groupBy = (elements, groupKey) => {\n  return elements.reduce((acc, next) => {\n    const key = groupKey(next);\n    if (key) {\n      let group = acc[key];\n      if (group) {\n        group.push(next);\n      } else {\n        const newGroup = [next];\n        group = newGroup;\n        acc[key] = newGroup;\n      }\n    }\n    return acc;\n  }, {});\n};\nconst identity = (r) => r;\nconst identityAsync = async (value, mode = \"micro\") => new Promise((resolve) => {\n  if (mode === \"micro\") {\n    resolve(value);\n  } else {\n    setTimeout(() => {\n      resolve(value);\n    }, 0);\n  }\n});\nconst normalizeMemoizeOptions = (options) => {\n  return {\n    argHasher: options?.argHasher ?? JSON.stringify,\n    thisContext: options?.thisContext,\n    maxCacheEntries: options?.maxCacheEntries ?? 10\n  };\n};\nconst memoize = (fn, rawOptions) => {\n  const options = normalizeMemoizeOptions(rawOptions);\n  const cache = /* @__PURE__ */ new Map();\n  const dropQueue = [];\n  return (...args) => {\n    const argsHash = options.argHasher(args);\n    if (cache.has(argsHash)) {\n      return cache.get(argsHash);\n    } else {\n      const result = fn.apply(options.thisContext, args);\n      cache.set(argsHash, result);\n      dropQueue.push(argsHash);\n      if (options.maxCacheEntries > 0 && dropQueue.length > options.maxCacheEntries) {\n        const cacheToDrop = dropQueue.shift();\n        cache.delete(cacheToDrop);\n      }\n      return result;\n    }\n  };\n};\nconst noop = () => void 0;\nconst noopAsync = (mode = \"micro\") => new Promise((resolve) => {\n  if (mode === \"micro\") {\n    resolve(void 0);\n  } else {\n    setTimeout(() => {\n      resolve(void 0);\n    }, 0);\n  }\n});\nconst normalizeRegExpLikeToRegExp = (regExpLike) => {\n  return typeof regExpLike === \"string\" ? new RegExp(regExpLike) : regExpLike;\n};\nconst sleep = (ms) => {\n  if (ms > 0) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n};\nconst yes = () => true;\nconst yesAsync = (mode = \"micro\") => new Promise((resolve) => {\n  if (mode === \"micro\") {\n    resolve(true);\n  } else {\n    setTimeout(() => {\n      resolve(true);\n    }, 0);\n  }\n});\nconst closestNumber = (numbers, target) => numbers.reduce(\n  (prev, curr) => Math.abs(curr - target) < Math.abs(prev - target) ? curr : prev\n);\nconst deepFreeze = (object, dontFreeze = /* @__PURE__ */ new Set()) => {\n  dontFreeze.add(object);\n  const propNames = Reflect.ownKeys(object);\n  for (const name of propNames) {\n    const value = object[name];\n    if ((value && typeof value === \"object\" || typeof value === \"function\") && !dontFreeze.has(value)) {\n      deepFreeze(value, dontFreeze);\n    }\n  }\n  return Object.freeze(object);\n};\nfunction isObject(item) {\n  return item !== null && item !== void 0 && typeof item === \"object\" && !Array.isArray(item);\n}\nconst deepMapObject = (o, mapper) => {\n  const target = structuredClone(o);\n  if (isObject(target)) {\n    for (const key in target) {\n      const value = target[key];\n      if (isObject(value)) {\n        Object.assign(value, deepMapObject(value, mapper));\n      } else {\n        Object.assign(target, { [key]: mapper(key, value) ?? value });\n      }\n    }\n  }\n  return target;\n};\nconst defaultDropKeyMatcher = (value, _key) => value === void 0;\nconst dropKeys = (t, matcher = defaultDropKeyMatcher) => {\n  for (const key in t) {\n    if (matcher(t[key], key)) {\n      delete t[key];\n    }\n    if (isObject(t[key])) {\n      dropKeys(t[key], matcher);\n    }\n  }\n  return t;\n};\nconst deepMergeInternal = (sources, options, visited = /* @__PURE__ */ new Set()) => {\n  const firstSource = sources.shift();\n  visited.add(firstSource);\n  const merged = structuredClone(firstSource);\n  for (const source of sources) {\n    visited.add(source);\n    if (Array.isArray(source) && Array.isArray(merged)) {\n      for (const element of source) {\n        if (!merged.includes(element)) {\n          merged.push(element);\n        }\n      }\n    } else if (isObject(source) && isObject(merged)) {\n      for (const key in source) {\n        const sourceValue = source[key];\n        if (Object.hasOwn(merged, key) && merged[key] === void 0 && options?.preferUndefined) {\n          continue;\n        }\n        if (isObject(sourceValue)) {\n          if (merged[key]) {\n            merged[key] = deepMergeInternal(\n              [merged[key], structuredClone(sourceValue)],\n              options,\n              visited\n            );\n          } else {\n            Object.assign(merged, { [key]: structuredClone(sourceValue) });\n          }\n        } else {\n          Object.assign(merged, { [key]: structuredClone(sourceValue) });\n        }\n      }\n    }\n  }\n  if (options?.dropKeys) {\n    const matcher = typeof options.dropKeys === \"function\" ? options.dropKeys : defaultDropKeyMatcher;\n    dropKeys(merged, matcher);\n  }\n  return merged;\n};\nconst deepMerge = (sources, options) => {\n  return deepMergeInternal(sources, options);\n};\nconst fillStringWithTemplateVariables = (value, variables) => {\n  return Object.entries(variables).reduce((acc, [variableKey, variableValue]) => {\n    return acc.replaceAll(\"${\" + variableKey + \"}\", variableValue);\n  }, value);\n};\nconst fillObjectWithTemplateVariables = (target, variables) => {\n  return deepMapObject(target, (_key, value) => {\n    return typeof value === \"string\" ? fillStringWithTemplateVariables(value, variables) : void 0;\n  });\n};\nconst isNotNullish = (o) => o !== void 0 && o !== null;\nconst isNullish = (o) => o === void 0 || o === null;\nconst isPromiseLike = (candidate) => {\n  return isNotNullish(candidate) && typeof candidate === \"object\" && typeof candidate[\"then\"] === \"function\" && typeof candidate[\"catch\"] === \"function\";\n};\nconst mapObject = (o, map) => {\n  return Object.fromEntries(\n    Object.entries(o).map(([key, value]) => {\n      return [key, map(value, key)];\n    })\n  );\n};\nconst drySync = (isDry, whenWet, dryDefault = true) => {\n  return isDry ? () => identity(dryDefault) : whenWet;\n};\nconst dry = (isDry, whenWet, dryDefault = true) => {\n  return isDry ? () => identityAsync(dryDefault) : whenWet;\n};\nconst normalizeDryOption = (options) => {\n  return {\n    dry: options?.dry ?? false\n  };\n};\nconst normalizeForceOption = (options) => {\n  return {\n    force: options?.force ?? false\n  };\n};\nconst normalizeSafeOption = (options) => {\n  return {\n    safe: options?.safe ?? false\n  };\n};\nconst arrayToObject = (a) => {\n  return a.reduce((acc, next) => {\n    acc[next] = next;\n    return acc;\n  }, {});\n};\nconst sortObject = (o, sortPreferences = []) => {\n  if (sortPreferences.length === 0 || !sortPreferences.some(\n    (pref) => typeof pref === \"object\" ? pref.key === \".*\" : pref === \".*\"\n  )) {\n    sortPreferences.push(\".*\");\n  }\n  const plainLevelOrder = sortPreferences.map(\n    (pref) => typeof pref === \"object\" ? pref.key : pref\n  );\n  const regexpLevelOrder = plainLevelOrder.map((pref) => new RegExp(pref));\n  const isArray = Array.isArray(o);\n  let obj = o;\n  if (isArray) {\n    obj = arrayToObject(o);\n  }\n  const ordered = Object.entries(obj).map(([key, value]) => {\n    let order = -1;\n    const regexpIndices = regexpLevelOrder.map((orderingRegExp, i) => orderingRegExp.test(key) ? i : -1).filter((index) => index > -1);\n    const plainIndex = plainLevelOrder.indexOf(key);\n    if (plainIndex >= 0) {\n      order = plainIndex;\n    } else {\n      if (regexpIndices.length > 1) {\n        const shaked = [...regexpLevelOrder, new RegExp(key)].sort(\n          (a, b) => a.test(b.source) || b.test(a.source) ? -1 : a.source.localeCompare(b.source)\n        ).map((r) => r.source);\n        const shakedKey = shaked.indexOf(key);\n        order = closestNumber(regexpIndices, shakedKey);\n      } else if (regexpIndices[0]) {\n        order = regexpIndices[0];\n      }\n    }\n    if (value !== void 0 && value !== null && typeof value === \"object\") {\n      const subOrdering = sortPreferences.filter((pref) => typeof pref === \"object\").find((preference) => new RegExp(preference.key).test(key));\n      return [key, sortObject(value, subOrdering?.order), order];\n    } else {\n      return [key, value, order];\n    }\n  }).sort(([ak, _av, aOrder], [bk, _bv, bOrder]) => {\n    return aOrder >= 0 && bOrder >= 0 && aOrder !== bOrder ? aOrder - bOrder : ak.localeCompare(bk);\n  });\n  return isArray ? ordered.map((item) => item[1]) : Object.fromEntries(ordered);\n};\nexport {\n  DEFAULT_ES_TARGET_NAME,\n  DEFAULT_ES_TARGET_YEAR,\n  asyncFilter,\n  asyncFilterMap,\n  asyncMap,\n  closestNumber,\n  deepFreeze,\n  deepMapObject,\n  deepMerge,\n  defaultDropKeyMatcher,\n  dropKeys,\n  dry,\n  drySync,\n  fillObjectWithTemplateVariables,\n  fillStringWithTemplateVariables,\n  groupBy,\n  identity,\n  identityAsync,\n  isNotNullish,\n  isNullish,\n  isObject,\n  isPromiseFulfilled,\n  isPromiseLike,\n  mapObject,\n  memoize,\n  noop,\n  noopAsync,\n  normalizeDryOption,\n  normalizeForceOption,\n  normalizeMemoizeOptions,\n  normalizeRegExpLikeToRegExp,\n  normalizeSafeOption,\n  sleep,\n  sortObject,\n  yes,\n  yesAsync\n};\n", "import { isNotNullish } from \"@alexaegis/common\";\nimport { withLatestFrom, filter, map, Subject, throttleTime, asyncScheduler, Subscription, EMPTY, Observable, BehaviorSubject, combineLatest, distinctUntilChanged, tap, shareReplay, switchMap, of, take, zip, catchError, share, skip, finalize, takeWhile, startWith, pairwise, NEVER, firstValueFrom, scheduled, asapScheduler } from \"rxjs\";\nconst DEFAULT_ACTION_CONFIG = {\n  throttleTime: void 0\n};\nconst isActionPacket = (actionPacket, registeredInActionMap) => {\n  return actionPacket !== void 0 && isNotNullish(actionPacket.type) && (registeredInActionMap?.has(actionPacket.type) ?? true);\n};\nconst includesArrayComparator = (prev, next) => prev.every((slice) => next.includes(slice));\nconst fastArrayComparator = (prev, next) => {\n  if (prev.length !== next.length) {\n    return false;\n  } else if (next.length === 0) {\n    return true;\n  } else {\n    for (let i = 0; i <= next.length; i++) {\n      if (prev[i] !== next[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\nconst TINYSLICE_PREFIX = \"[TinySlice]\";\nconst TINYSLICE_INTERNAL_PREFIX = `${TINYSLICE_PREFIX} [Internal]`;\nconst TINYSLICE_DEFAULT_PREFIX = `${TINYSLICE_PREFIX} [Default]`;\nconst entitySliceReducerWithPrecompute = (precompute, entityReducer) => {\n  return (state, payload) => {\n    const precomputed = precompute(state, payload);\n    return Object.entries(state).reduce(\n      (acc, [key, tile]) => {\n        acc[key] = entityReducer(key, tile, payload, precomputed) ?? tile;\n        return acc;\n      },\n      // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter\n      {}\n    );\n  };\n};\nconst entitySliceReducer = (entityReducer) => {\n  return (state, payload) => Object.entries(state).reduce(\n    (acc, [key, tile]) => {\n      acc[key] = entityReducer(key, tile, payload) ?? tile;\n      return acc;\n    },\n    // eslint-disable-next-line @typescript-eslint/prefer-reduce-type-parameter\n    {}\n  );\n};\nconst hasKey = (parent, key) => {\n  return isNotNullish(key) && isNotNullish(parent) && typeof parent === \"object\" && Object.hasOwn(parent, key);\n};\nfunction ifLatestFrom(input, condition) {\n  return (source) => {\n    return source.pipe(\n      withLatestFrom(input),\n      filter(([sourceResult, inputResult]) => condition(inputResult, sourceResult)),\n      map(([a]) => a)\n    );\n  };\n}\nconst getObjectKeys = (state) => Object.keys(state);\nconst getObjectKeysAsNumbers = (state) => Object.keys(state).map((key) => Number.parseInt(key, 10));\nconst getNextNumberLikeStringKey = (keys) => (keys.map((key) => Number.parseInt(key, 10)).reduce((a, b) => a > b ? a : b, 0) + 1).toString();\nconst getNextLargestNumber = (keys) => keys.reduce((a, b) => a > b ? a : b, 0) + 1;\nconst getNextSmallestNumber = (keys) => {\n  const sortedKeys = [...keys].sort((a, b) => a - b);\n  for (let i = 0; i < sortedKeys.length; i++) {\n    if (!sortedKeys.includes(i + 1)) {\n      return i + 1;\n    }\n  }\n  return (sortedKeys.at(-1) ?? 0) + 1;\n};\nvar PremadeGetNext = /* @__PURE__ */ ((PremadeGetNext2) => {\n  PremadeGetNext2[\"nextLargest\"] = \"nextlargest\";\n  PremadeGetNext2[\"nextSmallest\"] = \"nextsmallest\";\n  return PremadeGetNext2;\n})(PremadeGetNext || {});\nconst getNextKeyStrategy = (nextKeyStrategy) => {\n  if (typeof nextKeyStrategy === \"function\") {\n    return nextKeyStrategy;\n  } else if (nextKeyStrategy === \"nextlargest\") {\n    return getNextLargestNumber;\n  } else if (nextKeyStrategy === \"nextsmallest\") {\n    return getNextSmallestNumber;\n  } else {\n    return getNextLargestNumber;\n  }\n};\nconst isNonNullable = (o) => o !== void 0 && o !== null;\nconst isNullish = (o) => o === void 0 || o === null;\nconst updateObject = (base, other) => {\n  if (other !== void 0 && other !== null) {\n    if (typeof base === \"object\") {\n      if (Array.isArray(base)) {\n        const copy = [...base];\n        for (const [key, value] of other.entries()) {\n          if (value !== void 0) {\n            copy[key] = value;\n          }\n        }\n        return copy;\n      } else {\n        return { ...base, ...other };\n      }\n    } else {\n      return other;\n    }\n  } else {\n    return base;\n  }\n};\nclass Action extends Subject {\n  //\toverride subscribe;\n  /**\n   * TODO: Make this private, refactor angular solution\n   * @param type\n   * @param config\n   */\n  constructor(type, config = DEFAULT_ACTION_CONFIG) {\n    super();\n    this.type = type;\n    this.config = {\n      ...DEFAULT_ACTION_CONFIG,\n      ...config\n    };\n    this.actionPipeline = this;\n    if (isNotNullish(this.config.pauseWhile)) {\n      this.actionPipeline = this.actionPipeline.pipe(\n        ifLatestFrom(this.config.pauseWhile, (paused) => !paused)\n      );\n    }\n    if (isNotNullish(this.config.throttleTime)) {\n      this.actionPipeline = this.actionPipeline.pipe(\n        throttleTime(this.config.throttleTime, asyncScheduler, {\n          leading: true,\n          trailing: true\n        })\n      );\n    }\n  }\n  dispatchSubscription;\n  config;\n  scope;\n  registrations = new Subscription();\n  /**\n   * This will emit every action of this type, both direct dispatches and\n   * effect dispatches\n   */\n  get listenPackets$() {\n    return this.scope?.listen$(this) ?? EMPTY;\n  }\n  /**\n   * This won't receive actions from effects\n   */\n  get listen$() {\n    return this.actionPipeline;\n  }\n  actionPipeline;\n  register(scope) {\n    this.scope = scope;\n    this.dispatchSubscription = this.scope.registerAction(this, true);\n    return this;\n  }\n  unregister() {\n    this.dispatchSubscription?.unsubscribe();\n  }\n  makePacket(payload) {\n    return { type: this.type, payload };\n  }\n  /**\n   * The finalize operator will take care of removing it from the actionMap\n   */\n  complete() {\n    this.unregister();\n    this.registrations.unsubscribe();\n    this.unsubscribe();\n  }\n  /**\n   *\n   */\n  getFilter() {\n    return (source) => source.pipe(filter((value) => value.type === this.type));\n  }\n  static makeFilter(...actions) {\n    const allowedTypes = new Set(actions.map((action) => action.type));\n    return (source) => source.pipe(filter((value) => allowedTypes.has(value.type)));\n  }\n  reduce(actionReducer) {\n    return {\n      packetReducer: (state, actionPacket) => actionPacket ? actionReducer(state, actionPacket.payload) : state,\n      action: this\n    };\n  }\n}\nconst isReduceActionSliceSnapshot = (t) => isNotNullish(t.actionPacket);\nconst extractSliceOptions = (constructOptions) => {\n  return {\n    defineInternals: constructOptions?.defineInternals,\n    metaReducers: constructOptions?.metaReducers,\n    plugins: constructOptions?.plugins,\n    reducers: constructOptions?.reducers\n  };\n};\nconst normalizeSliceDirection = (sliceDirection) => {\n  if (typeof sliceDirection === \"object\") {\n    return sliceDirection;\n  } else {\n    const key = sliceDirection;\n    const selector = (state) => {\n      return isNotNullish(state) && typeof state === \"object\" ? state[key] : void 0;\n    };\n    const merger = (parentState, state) => {\n      if (isNullish(parentState)) {\n        return parentState;\n      }\n      return typeof parentState === \"object\" ? {\n        ...parentState,\n        [key]: state\n      } : parentState;\n    };\n    return {\n      merger,\n      selector\n    };\n  }\n};\nclass Slice extends Observable {\n  sink = new Subscription();\n  options;\n  scope;\n  initialState;\n  parentCoupling;\n  initialReducers;\n  initialPlugins;\n  state$;\n  _pathSegment;\n  _absolutePath;\n  setAction;\n  updateAction;\n  deleteKeyAction;\n  defineKeyAction;\n  observableState$;\n  defaultReducerConfigurations;\n  reducerConfigurations$;\n  autoRegisterReducerActions$;\n  downStreamReducers$;\n  sliceReducer$;\n  sliceReducingActions$;\n  plugins$;\n  autoRegisterPlugins$;\n  nullishParentPause$;\n  manualPause$;\n  pause$;\n  keyedSlices$ = new BehaviorSubject({});\n  slices$ = this.keyedSlices$.pipe(map((keyedSlices) => Object.values(keyedSlices)));\n  subscribe;\n  // Listens to the parent for changes to select itself from\n  // check if the parent could do it instead\n  parentListener;\n  inactivePipeline;\n  activePipeline;\n  pipeline;\n  defineInternals;\n  _internals;\n  scopedActions = [];\n  get internals() {\n    return this._internals;\n  }\n  get absolutePath() {\n    return this._absolutePath;\n  }\n  get pathSegment() {\n    return this._pathSegment;\n  }\n  /**\n   * For debugging purposes\n   */\n  printSliceStructure(indentationLevel = 0) {\n    if (indentationLevel === 0) {\n      console.groupCollapsed(\"Slice Structure\", this.absolutePath);\n    }\n    console.log(\"\t\".repeat(indentationLevel) + this.pathSegment);\n    for (const [, value] of Object.entries(this.keyedSlices$.value)) {\n      value.slice.printSliceStructure(indentationLevel + 1);\n    }\n    if (indentationLevel === 0) {\n      console.groupEnd();\n    }\n  }\n  /**\n   *\n   * @param initialState\n   * @param sliceSegment a string that represents this slice, has to be\n   * unique on it's parent.\n   */\n  constructor(options) {\n    super();\n    this.options = options;\n    this.scope = options.scope;\n    this._pathSegment = options.pathSegment;\n    this.initialState = options.initialState;\n    this.parentCoupling = options.parentCoupling;\n    this.initialReducers = options.reducers ?? [];\n    this.initialPlugins = options.plugins ?? [];\n    this.defineInternals = options.defineInternals;\n    this.nullishParentPause$ = new BehaviorSubject(false);\n    this.manualPause$ = new BehaviorSubject(false);\n    this.pause$ = combineLatest([this.nullishParentPause$, this.manualPause$]).pipe(\n      map(([nullishParentPause, manualPause]) => nullishParentPause || manualPause)\n    );\n    this._absolutePath = Slice.calculateAbsolutePath(this.parentCoupling, this._pathSegment);\n    this.setAction = this.createAction(`${TINYSLICE_DEFAULT_PREFIX} set`);\n    this.updateAction = this.createAction(`${TINYSLICE_DEFAULT_PREFIX} update`);\n    this.deleteKeyAction = this.createAction(\n      `${TINYSLICE_DEFAULT_PREFIX} delete key`\n    );\n    this.defineKeyAction = this.createAction(\n      `${TINYSLICE_DEFAULT_PREFIX} define key`\n    );\n    this.state$ = new BehaviorSubject(this.initialState);\n    this.observableState$ = this.state$.pipe(distinctUntilChanged());\n    this.defaultReducerConfigurations = [\n      this.setAction.reduce((_state, payload) => payload),\n      this.updateAction.reduce((state, payload) => updateObject(state, payload)),\n      this.deleteKeyAction.reduce((state, payload) => {\n        if (typeof state === \"object\") {\n          const nextState = { ...state };\n          delete nextState[payload];\n          return nextState;\n        } else {\n          return state;\n        }\n      }),\n      this.defineKeyAction.reduce((state, payload) => {\n        return typeof state === \"object\" ? {\n          ...state,\n          [payload.key]: payload.data\n        } : state;\n      })\n    ];\n    this.reducerConfigurations$ = new BehaviorSubject([\n      ...this.defaultReducerConfigurations,\n      ...this.initialReducers\n    ]);\n    this.autoRegisterReducerActions$ = this.reducerConfigurations$.pipe(\n      tap((reducerConfigurations) => {\n        for (const reducerConfiguration of reducerConfigurations) {\n          this.scope.registerAction(reducerConfiguration.action);\n        }\n      })\n    );\n    this.sliceReducer$ = this.reducerConfigurations$.pipe(\n      map(\n        (reducerConfigurations) => (state, action) => action ? reducerConfigurations.filter((rc) => rc.action.type === action.type).reduce(\n          (acc, { packetReducer }) => packetReducer(acc, action),\n          state\n        ) : state\n      ),\n      shareReplay(1)\n    );\n    this.sliceReducingActions$ = this.reducerConfigurations$.pipe(\n      map((reducerConfigurations) => [\n        ...new Set(reducerConfigurations.map((r) => r.action.type))\n      ]),\n      shareReplay(1)\n    );\n    this.downStreamReducers$ = this.slices$.pipe(\n      withLatestFrom(this.sliceReducingActions$),\n      switchMap(([slices, sliceReducingActions]) => {\n        return slices.length > 0 ? combineLatest(slices.map((next) => next.slice.downStreamReducers$)).pipe(\n          map((subSliceReducer) => [\n            ...sliceReducingActions,\n            ...subSliceReducer.flat()\n          ])\n        ) : of(sliceReducingActions);\n      }),\n      shareReplay(1)\n      // computed from a behaviorSubject and another computed field\n    );\n    const slicesWithDownStreamReducers$ = this.slices$.pipe(\n      switchMap((sliceRegistrations) => {\n        return sliceRegistrations.length > 0 ? combineLatest(\n          sliceRegistrations.map(\n            (sliceRegistration) => sliceRegistration.slice.downStreamReducers$.pipe(\n              map((downStreamReducers) => ({\n                downStreamReducers,\n                sliceRegistration\n              }))\n            )\n          )\n        ) : of([]);\n      }),\n      shareReplay(1)\n      // computed from behaviorSubjects from a behaviorSubject\n    );\n    const schedulingDispatcher$ = this.scope.schedulingDispatcher$.pipe(\n      ifLatestFrom(\n        this.downStreamReducers$,\n        (downStreamReducers, actionPacket) => downStreamReducers.includes(actionPacket.type)\n      ),\n      tap((actionPacket) => {\n        this.executeMetaPreReducers(actionPacket);\n      })\n    );\n    const dispatchAndSlices$ = schedulingDispatcher$.pipe(\n      switchMap(\n        (actionPacket) => slicesWithDownStreamReducers$.pipe(\n          take(1),\n          map((slicesWithDownStreamReducers) => ({\n            actionPacket,\n            slicesWithDownStreamReducers\n          }))\n        )\n      )\n    );\n    const filterSliceRegistrationBasedOnActionTypeSupport = (slicesWithDownStreamReducers, actionType) => {\n      return slicesWithDownStreamReducers.map(({ sliceRegistration, downStreamReducers }) => {\n        return downStreamReducers.includes(actionType) ? sliceRegistration.slice.pipeline.pipe(\n          map(\n            (snapshot) => ({\n              snapshot,\n              sliceRegistration\n            })\n          )\n        ) : void 0;\n      }).filter(isNotNullish);\n    };\n    const zippedDispatch = dispatchAndSlices$.pipe(\n      switchMap(({ slicesWithDownStreamReducers, actionPacket }) => {\n        const neededChildSlices = filterSliceRegistrationBasedOnActionTypeSupport(\n          slicesWithDownStreamReducers,\n          actionPacket.type\n        );\n        return neededChildSlices.length > 0 ? zip(neededChildSlices).pipe(\n          map((sliceChanges) => ({ sliceChanges, actionPacket }))\n        ) : of({ sliceChanges: [], actionPacket });\n      })\n    );\n    this.activePipeline = zippedDispatch.pipe(\n      withLatestFrom(this.state$, this.sliceReducer$),\n      map(\n        ([\n          { actionPacket, sliceChanges },\n          prevState,\n          sliceReducer\n        ]) => {\n          if (this.isRootOrParentStateUndefined()) {\n            return {\n              actionPacket,\n              prevState,\n              nextState: prevState\n            };\n          }\n          const nextState = sliceChanges.filter(\n            (sliceChange) => sliceChange.snapshot.prevState !== sliceChange.snapshot.nextState\n          ).reduce(\n            (prevState2, sliceChange) => sliceChange.sliceRegistration.slicer.merger(\n              prevState2,\n              sliceChange.snapshot.nextState\n            ),\n            prevState\n          ) ?? prevState;\n          return {\n            actionPacket,\n            prevState,\n            nextState: sliceReducer(nextState, actionPacket)\n          };\n        }\n      ),\n      tap((snapshot) => {\n        if (snapshot.prevState !== snapshot.nextState) {\n          this.state$.next(snapshot.nextState);\n        }\n      }),\n      catchError((error, pipeline$) => {\n        console.error(`${TINYSLICE_PREFIX} slice pipeline error \n`, error);\n        return this.plugins$.pipe(\n          take(1),\n          tap((plugins) => {\n            for (const plugin of plugins) {\n              plugin.onError?.(error);\n            }\n          }),\n          switchMap(() => pipeline$)\n        );\n      })\n    );\n    this.inactivePipeline = schedulingDispatcher$.pipe(\n      withLatestFrom(this.state$),\n      map(([, state]) => {\n        return {\n          actionPacket: { type: \"paused\", payload: void 0 },\n          prevState: state,\n          nextState: state\n        };\n      })\n    );\n    this.pipeline = this.pause$.pipe(\n      switchMap((paused) => paused ? this.inactivePipeline : this.activePipeline),\n      tap((snapshot) => {\n        this.executeMetaPostReducers(snapshot);\n      }),\n      share()\n      // has to be shared because of child listeners\n    );\n    this.plugins$ = new BehaviorSubject(this.initialPlugins);\n    this.parentListener = this.parentCoupling?.rawParentState.pipe(\n      skip(1),\n      finalize(() => {\n        this.complete();\n      }),\n      takeWhile(\n        (parentState) => this.parentCoupling?.droppable ? hasKey(parentState, this.parentCoupling.key) : true\n      ),\n      tap((parentState) => {\n        if (isNullish(parentState) && !this.nullishParentPause$.value) {\n          this.nullishParentPause$.next(true);\n        } else if (this.nullishParentPause$.value) {\n          this.nullishParentPause$.next(false);\n        }\n      }),\n      filter(isNotNullish),\n      map((parentState) => this.parentCoupling?.slicer.selector(parentState)),\n      distinctUntilChanged(),\n      tap((stateFromParent) => {\n        this.state$.next(stateFromParent);\n      })\n    );\n    this.autoRegisterPlugins$ = this.plugins$.pipe(\n      startWith([]),\n      pairwise(),\n      tap(([previous, next]) => {\n        for (const plugin of previous.filter((plugin2) => !next.includes(plugin2))) {\n          plugin.stop();\n        }\n        for (const plugin of next.filter((plugin2) => !previous.includes(plugin2))) {\n          this.registerPlugin(plugin);\n        }\n      })\n    );\n    this.subscribe = this.observableState$.pipe(filter(isNotNullish)).subscribe.bind(this.observableState$);\n    this.scope.slices.set(this._absolutePath, this);\n    if (this.parentCoupling) {\n      this.parentCoupling.parentSlice.registerSlice({\n        slice: this,\n        slicer: this.parentCoupling.slicer,\n        initialState: this.initialState,\n        key: this.parentCoupling.key\n      });\n      this.sink.add(this.parentListener?.subscribe());\n    }\n    this.sink.add(this.autoRegisterReducerActions$.subscribe());\n    this.sink.add(this.autoRegisterPlugins$.subscribe());\n    this.sink.add(this.pipeline.subscribe());\n    this._internals = this.defineInternals?.(this) ?? {};\n  }\n  executeMetaPreReducers(action) {\n    for (const plugin of this.plugins$.value) {\n      if (!this.options.parentCoupling) {\n        plugin.preRootReduce?.(this._absolutePath, this.state$.value, action);\n      }\n      plugin.preReduce?.(this._absolutePath, this.state$.value, action);\n    }\n  }\n  executeMetaPostReducers(snapshot) {\n    for (const plugin of this.plugins$.value) {\n      plugin.postReduce?.(this._absolutePath, snapshot);\n      if (!this.options.parentCoupling) {\n        plugin.postRootReduce?.(this._absolutePath, snapshot);\n      }\n    }\n  }\n  loadAndSetPlugins(...pluginImports) {\n    return Promise.all(pluginImports.map((pluginImport) => pluginImport())).then((plugins) => {\n      this.setPlugins(plugins);\n      return plugins;\n    });\n  }\n  get paused$() {\n    return this.pause$;\n  }\n  /**\n   * Unpauses this slice and every child slice recursively\n   */\n  unpause() {\n    if (this.manualPause$.value) {\n      this.manualPause$.next(false);\n    }\n    for (const subSlice of Object.values(this.keyedSlices$.value)) {\n      subSlice.slice.unpause();\n    }\n  }\n  /**\n   * Pauses this slice and every child slice recursively\n   */\n  pause() {\n    if (!this.manualPause$.value) {\n      this.manualPause$.next(true);\n    }\n    for (const subSlice of Object.values(this.keyedSlices$.value)) {\n      subSlice.slice.pause();\n    }\n  }\n  /**\n   * Effects created here will respond to the pause and unpauseEffects functions.\n   * These effects will also unsubscribe if the slice unsubscribes\n   */\n  createEffect(packet$) {\n    const pausablePacket$ = this.paused$.pipe(\n      switchMap((isPaused) => isPaused ? NEVER : packet$)\n    );\n    const effectSubscription = this.scope.createEffect(pausablePacket$);\n    this.sink.add(effectSubscription);\n    return effectSubscription;\n  }\n  setPlugins(plugins) {\n    this.plugins$.next([...this.options.plugins ?? [], ...plugins]);\n  }\n  getPlugins() {\n    return this.plugins$.value;\n  }\n  addPlugin(...plugins) {\n    this.plugins$.next([...this.plugins$.value, ...plugins]);\n  }\n  getReducers() {\n    return this.reducerConfigurations$.value;\n  }\n  /**\n   * This does not disable default redurces.\n   */\n  setReducers(reducers) {\n    this.reducerConfigurations$.next([...this.defaultReducerConfigurations, ...reducers]);\n  }\n  addReducers(reducers) {\n    this.reducerConfigurations$.next([...this.reducerConfigurations$.value, ...reducers]);\n  }\n  static assembleAbsolutePath(parentAbsolutePath, segment) {\n    return `${parentAbsolutePath}${parentAbsolutePath ? \".\" : \"\"}${segment}`;\n  }\n  static calculateAbsolutePath(parentCoupling, pathSegment) {\n    return parentCoupling ? Slice.assembleAbsolutePath(parentCoupling.parentSlice._absolutePath, pathSegment) : pathSegment;\n  }\n  registerPlugin(plugin) {\n    plugin.register({\n      initialState: this.state$.value,\n      state$: this.pipeline,\n      stateInjector: (state) => {\n        this.state$.next(state);\n      }\n    });\n    plugin.start();\n    return plugin;\n  }\n  set(slice) {\n    this.setAction.next(slice);\n  }\n  update(slice) {\n    this.updateAction.next(slice);\n  }\n  set value(value) {\n    this.set(value);\n  }\n  get value() {\n    return this.state$.value;\n  }\n  isRootOrParentStateUndefined() {\n    return this.parentCoupling ? isNullish(this.parentCoupling.parentSlice.state$.value) : false;\n  }\n  static createRootSlice(scope, initialState, sliceOptions) {\n    return new Slice({\n      ...extractSliceOptions(sliceOptions),\n      scope,\n      initialState,\n      pathSegment: \"root\"\n    });\n  }\n  createAction(name, actionOptions) {\n    const actionName = `${this._absolutePath} ${name}`;\n    const action = this.scope.createAction(actionName, {\n      ...actionOptions,\n      pauseWhile: this.paused$\n    });\n    this.scopedActions.push(action);\n    return action;\n  }\n  sliceInternal(childSliceConstructOptions) {\n    const path = Slice.assembleAbsolutePath(\n      this._absolutePath,\n      childSliceConstructOptions.pathSegment.toString()\n    );\n    if (this.scope.slices.has(path)) {\n      return this.scope.slices.get(path);\n    } else {\n      const initialStateFromParent = this.state$.value ? childSliceConstructOptions.slicer.selector(this.state$.value) : void 0;\n      const initialState = initialStateFromParent ?? childSliceConstructOptions.initialState;\n      return new Slice({\n        ...extractSliceOptions(childSliceConstructOptions),\n        plugins: [\n          ...this.plugins$.value.filter(\n            (plugin) => plugin.sliceOptions?.()?.passToChildren ?? false\n          ),\n          ...childSliceConstructOptions.plugins ?? []\n        ],\n        scope: this.scope,\n        initialState,\n        parentCoupling: {\n          parentSlice: this,\n          rawParentState: this.observableState$,\n          slicer: childSliceConstructOptions.slicer,\n          droppable: childSliceConstructOptions.droppable,\n          key: childSliceConstructOptions.key\n        },\n        pathSegment: childSliceConstructOptions.pathSegment\n      });\n    }\n  }\n  /**\n   * @deprecated remove this, too much trouble because of selector.toString(), use dice instead\n   */\n  sliceSelect(selector, merger, sliceOptions) {\n    return this.sliceInternal({\n      ...sliceOptions,\n      initialState: void 0,\n      droppable: false,\n      slicer: {\n        selector,\n        merger\n      },\n      key: void 0,\n      pathSegment: selector.toString()\n    });\n  }\n  slice(key, sliceOptions) {\n    const slicer = normalizeSliceDirection(key);\n    return this.sliceInternal({\n      ...sliceOptions,\n      pathSegment: key.toString(),\n      slicer,\n      key,\n      droppable: false\n    });\n  }\n  /**\n   * Adds non-defined \"lazy\" slices to extend this slice\n   * ? https://github.com/microsoft/TypeScript/issues/42315\n   * ? key could be restricted to disallow keys of Slice once negated types\n   * ? are implemented in TypeScript\n   */\n  addSlice(key, initialState, sliceOptions) {\n    const slicer = normalizeSliceDirection(key);\n    return this.sliceInternal({\n      ...sliceOptions,\n      initialState,\n      pathSegment: key.toString(),\n      slicer,\n      key,\n      droppable: false\n    });\n  }\n  /**\n   * Adds a new lazy slice then dices it with a number type record,\n   * you can choose between nextKeyStrategies:\n   * - NEXT_SMALLEST\n   * - NEXT_LARGEST,\n   * - CUSTOM\n   *\n   * NEXT_LARGEST is the default as thats the simplest.\n   *\n   * ! make sure key doesn't exist via generics on State once that can be done in TS\n   */\n  addDicedSlice(key, initialState, diceConstructOptions) {\n    return this.addSlice(key, {}, diceConstructOptions.dicedSliceOptions).dice(\n      initialState,\n      {\n        ...diceConstructOptions,\n        getAllKeys: getObjectKeysAsNumbers,\n        getNextKey: getNextKeyStrategy(diceConstructOptions.getNextKeyStrategy)\n      }\n    );\n  }\n  /**\n   * This slice type is created on the fly for N subsclices of the same type\n   * great for complex entities that spawn on the fly and have their own\n   * state definition.\n   *\n   * This defines two layers of state at once. The middle layer stores the bottom layers\n   * you can ask for bottom layers lazyly using a selector. You'll then receive the\n   * slice object and, all the other guts you predefined, like state observers, actions, etc\n   *\n   * Actions are automatically scoped to these selected subslices\n   *\n   * Nomenclature: Slicing means to take a single piece of state, dicing is multiple\n   */\n  dice(initialState, diceConstructOptions) {\n    const sliceOptions = extractSliceOptions(diceConstructOptions);\n    const get = (key) => {\n      const slicer = normalizeSliceDirection(key);\n      return this.sliceInternal({\n        ...sliceOptions,\n        initialState,\n        pathSegment: key.toString(),\n        slicer,\n        key,\n        droppable: true\n      });\n    };\n    const has = (key) => this.state$.value && typeof this.state$.value === \"object\" ? Object.keys(this.state$.value).includes(key) : false;\n    const set = (key, data) => {\n      this.defineKeyAction.next({ key, data });\n    };\n    const remove = (key) => {\n      this.deleteKeyAction.next(key);\n    };\n    const keys = () => diceConstructOptions.getAllKeys(this.value);\n    const getNextKey = () => diceConstructOptions.getNextKey(keys());\n    const add = (data) => {\n      this.defineKeyAction.next({ key: getNextKey(), data });\n    };\n    const create = () => {\n      this.defineKeyAction.next({ key: getNextKey(), data: void 0 });\n    };\n    const keys$ = this.pipe(\n      map((state) => diceConstructOptions.getAllKeys(state)),\n      distinctUntilChanged(fastArrayComparator)\n    );\n    const items$ = keys$.pipe(\n      map((keys2) => keys2.map((key) => get(key))),\n      switchMap((slices) => slices.length > 0 ? combineLatest(slices) : of([]))\n    );\n    const count$ = keys$.pipe(map((keys2) => keys2.length));\n    const some$ = (predicate) => items$.pipe(map((items) => items.some(predicate)));\n    const every$ = (predicate) => items$.pipe(map((items) => items.every(predicate)));\n    const selectOnceDefined = (key) => firstValueFrom(\n      keys$.pipe(\n        filter((keys2) => keys2.includes(key)),\n        map(\n          () => this.slice(\n            key,\n            sliceOptions\n          )\n        )\n      )\n    );\n    return {\n      slice: this,\n      selectOnceDefined,\n      has,\n      get,\n      keys,\n      keys$,\n      count$,\n      items$,\n      some$,\n      every$,\n      add,\n      set,\n      remove,\n      create,\n      getNextKey\n    };\n  }\n  registerSlice(sliceRegistration) {\n    this.keyedSlices$.next({\n      ...this.keyedSlices$.value,\n      [sliceRegistration.slice._pathSegment]: sliceRegistration\n    });\n    if (!hasKey(this.value, sliceRegistration.key) || sliceRegistration.initialState !== sliceRegistration.slicer.selector(this.value)) {\n      this.setAction.next(\n        sliceRegistration.slicer.merger(\n          this.value,\n          sliceRegistration.initialState\n        )\n      );\n    }\n  }\n  /**\n   *\n   * @param pathSegment single segment, not the entire absolutePath\n   */\n  unregisterSlice(pathSegment) {\n    const nextSlicesSet = {\n      ...this.keyedSlices$.value\n    };\n    delete nextSlicesSet[pathSegment];\n    this.keyedSlices$.next(nextSlicesSet);\n  }\n  /**\n   * Tears down itself and anything below\n   */\n  complete() {\n    this.manualPause$.complete();\n    this.state$.complete();\n    this.keyedSlices$.complete();\n    this.plugins$.complete();\n    this.reducerConfigurations$.complete();\n    this.parentCoupling?.parentSlice.unregisterSlice(this.pathSegment);\n    for (const scopedAction of this.scopedActions) {\n      scopedAction.complete();\n    }\n    this.scope.slices.delete(this._absolutePath);\n    this.sink.unsubscribe();\n  }\n  asObservable() {\n    return this.pipe();\n  }\n}\nclass Scope {\n  schedulingDispatcher;\n  actionMap = /* @__PURE__ */ new Map();\n  schedulingDispatcher$;\n  effectSubscriptions;\n  stores;\n  slices;\n  constructor() {\n    this.schedulingDispatcher = new Subject();\n    this.schedulingDispatcher$ = this.schedulingDispatcher.asObservable();\n    this.actionMap = /* @__PURE__ */ new Map();\n    this.effectSubscriptions = new Subscription();\n    this.stores = [];\n    this.slices = /* @__PURE__ */ new Map();\n  }\n  createAction(type, config) {\n    return this.actionMap.has(type) ? this.actionMap.get(type) : new Action(type, config).register(this);\n  }\n  createRootSlice(initialState, rootSliceOptions) {\n    return Slice.createRootSlice(this, initialState, rootSliceOptions);\n  }\n  /**\n   * Using this ensures packets returned by effects are reduced on next tick.\n   * Otherwise the normal reducer could overwrite whatever the effect\n   * is producing.\n   * Let's say you'd write a typical useless machine, if the effect notices\n   * you set a boolean state to true, it sets it back to false immediately.\n   * Without this scheduling, the effects result could happen before the\n   * triggering actions reduce and the state would be left as true.\n   */\n  createEffect(action) {\n    const source = scheduled(action, asapScheduler).pipe(\n      tap((packet) => {\n        if (isActionPacket(packet, this.actionMap)) {\n          this.schedulingDispatcher.next(packet);\n        }\n      }),\n      catchError((error, pipeline$) => {\n        console.error(\n          `%c${TINYSLICE_PREFIX} error in effect!\n`,\n          \"background: #222, color: #e00;\",\n          error\n        );\n        return pipeline$;\n      })\n    );\n    const effectSubscription = source.subscribe();\n    this.effectSubscriptions.add(effectSubscription);\n    return effectSubscription;\n  }\n  /**\n   * Only used for cleanup\n   */\n  registerRootSlice(store) {\n    this.stores.push(store);\n  }\n  registerAction(action, registerFromAction = false) {\n    if (this.actionMap.has(action.type)) {\n      return;\n    }\n    this.actionMap.set(action.type, action);\n    const subscription = action.listen$.pipe(\n      map((payload) => action.makePacket(payload)),\n      finalize(() => this.actionMap.delete(action.type)),\n      tap((next) => {\n        this.schedulingDispatcher.next(next);\n      })\n    ).subscribe();\n    action.registrations.add(subscription);\n    if (!registerFromAction) {\n      action.register(this);\n    }\n    return subscription;\n  }\n  listen$(...actions) {\n    return this.schedulingDispatcher.pipe(Action.makeFilter(...actions));\n  }\n  listenAll$() {\n    return this.schedulingDispatcher.asObservable();\n  }\n  isRegistered(action) {\n    if (!action) {\n      return false;\n    }\n    const type = typeof action === \"string\" ? action : action.type;\n    return this.actionMap.has(type);\n  }\n  get closed() {\n    return this.schedulingDispatcher.closed;\n  }\n  complete() {\n    for (const [, action] of this.actionMap) {\n      action.complete();\n    }\n    this.actionMap.clear();\n    this.effectSubscriptions.unsubscribe();\n    this.schedulingDispatcher.complete();\n    for (const store of this.stores) {\n      store.complete();\n    }\n  }\n}\nexport {\n  Action,\n  DEFAULT_ACTION_CONFIG,\n  PremadeGetNext,\n  Scope,\n  Slice,\n  TINYSLICE_DEFAULT_PREFIX,\n  TINYSLICE_INTERNAL_PREFIX,\n  TINYSLICE_PREFIX,\n  entitySliceReducer,\n  entitySliceReducerWithPrecompute,\n  fastArrayComparator,\n  getNextKeyStrategy,\n  getNextLargestNumber,\n  getNextNumberLikeStringKey,\n  getNextSmallestNumber,\n  getObjectKeys,\n  getObjectKeysAsNumbers,\n  hasKey,\n  ifLatestFrom,\n  includesArrayComparator,\n  isActionPacket,\n  isNonNullable,\n  isNullish,\n  isReduceActionSliceSnapshot,\n  normalizeSliceDirection,\n  updateObject\n};\n"],
  "mappings": "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",
  "names": ["_a"]
}
