import { normalizeDryOption, dry } from "@alexaegis/common";
import { normalizeCollectWorkspacePackagesOptions, collectWorkspacePackages } from "@alexaegis/workspace-tools";
import { globby } from "globby";
import { existsSync } from "node:fs";
import { rm } from "node:fs/promises";
import { join, relative } from "node:path";
import { normalizeLoggerOption } from "@alexaegis/logging";
const DEFAULT_NUKE_LIST = [
  ".cache",
  "node_modules",
  "dist",
  ".turbo",
  "coverage",
  "package-lock.json",
  "pnpm-lock.yaml",
  "typedoc",
  ".svelte-kit"
];
const DEFAULT_NUKE_GLOBS = [
  "./vite.config.ts.timestamp*",
  "./vitest.config.ts.timestamp*"
];
const normalizeNukeOptions = (options) => {
  return {
    ...normalizeCollectWorkspacePackagesOptions(options),
    ...normalizeDryOption(options),
    ...normalizeLoggerOption(options),
    skipNodeModules: options?.skipNodeModules ?? false,
    nukeList: options?.nukeList ?? DEFAULT_NUKE_LIST,
    nukeGlobs: options?.nukeGlobs ?? DEFAULT_NUKE_GLOBS,
    nukeMoreGlobs: options?.nukeMoreGlobs ?? [],
    nukeMore: options?.nukeMore ?? [],
    dontNukeIn: options?.dontNukeIn ?? []
  };
};
const nuke = async (rawOptions) => {
  const options = normalizeNukeOptions(rawOptions);
  const allWorkspacePackages = await collectWorkspacePackages(options);
  if (allWorkspacePackages.length === 0) {
    throw new Error("not in a workspace!");
  }
  const nukeList = [...options.nukeList, ...options.nukeMore];
  const nukeGlobs = [...options.nukeGlobs, ...options.nukeMoreGlobs];
  const nonSkippedWorkspacePackages = allWorkspacePackages.filter(
    (workspacePackage) => !options.dontNukeIn.some(
      (skip) => typeof skip === "string" ? skip === workspacePackage.packagePath : skip.test(workspacePackage.packagePath)
    )
  );
  const rootPackage = allWorkspacePackages.find(
    (workspacePackage) => workspacePackage.packageKind === "root"
  );
  if (!rootPackage) {
    options.logger.error("Not inside a workspace!");
    return;
  }
  const packageFlatNukeTargets = nonSkippedWorkspacePackages.flatMap(
    (workspacePackage) => nukeList.map((toNuke) => join(workspacePackage.packagePath, toNuke))
  );
  const packageGlobNukeTargets = await Promise.all(
    nonSkippedWorkspacePackages.map(
      (packageDirectory) => globby(nukeGlobs, {
        cwd: packageDirectory.packagePath,
        dot: true,
        followSymbolicLinks: false,
        expandDirectories: false
      }).then((paths) => paths.map((path) => join(packageDirectory.packagePath, path)))
    )
  );
  const everyNukeTarget = [...packageFlatNukeTargets, ...packageGlobNukeTargets.flat()].sort();
  const dryRm = dry(options.dry, rm);
  await Promise.allSettled(
    everyNukeTarget.filter((nukeTarget) => existsSync(nukeTarget)).map((nukeTarget) => {
      options.logger.warn(
        "obliterating: " + relative(rootPackage.packagePath, nukeTarget)
      );
      return dryRm(nukeTarget, { recursive: true }).catch(() => false);
    })
  );
};
export {
  DEFAULT_NUKE_GLOBS,
  DEFAULT_NUKE_LIST,
  normalizeNukeOptions,
  nuke
};
