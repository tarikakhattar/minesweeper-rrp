import { normalizeDryOption, groupBy } from "@alexaegis/common";
import { normalizeLoggerOption } from "@alexaegis/logging";
import { existsSync } from "node:fs";
import { join, isAbsolute, extname } from "node:path";
import { lstat, readFile, writeFile, chmod } from "node:fs/promises";
import { load } from "js-yaml";
const normalizeCwdOption = (options) => {
  return {
    cwd: options?.cwd ?? process.cwd()
  };
};
const normalizePrettifyOptions = (options) => {
  return {
    ...normalizeCwdOption(options),
    ...normalizeLoggerOption(options),
    ...normalizeDryOption(options),
    parser: options?.parser ?? "babel"
  };
};
const getPrettierFormatter = async (rawOptions) => {
  const options = normalizePrettifyOptions(rawOptions);
  try {
    const prettier = await import("prettier");
    const prettierConfig = await prettier.resolveConfig(options.cwd, {
      editorconfig: true
    });
    const prettierOptions = {
      ...prettierConfig,
      parser: options.parser
    };
    return async (content) => {
      try {
        return await prettier.format(content, prettierOptions);
      } catch (error) {
        options.logger.error("prettier format failed", error);
        return content;
      }
    };
  } catch (error) {
    options.logger.warn("loading prettier failed", error);
    return (content) => content;
  }
};
const tryPrettify = async (content, options) => {
  const formatter = await getPrettierFormatter(options);
  return await formatter(content);
};
const normalizeDirectoryDepthOption = (options) => {
  return {
    depth: options?.depth ?? Number.POSITIVE_INFINITY
  };
};
const findNearestFile = (fileName, relativeTo = process.cwd()) => {
  let currentPath = relativeTo;
  for (; ; ) {
    if (existsSync(join(currentPath, fileName))) {
      return currentPath;
    }
    const parentPath = join(currentPath, "..");
    if (parentPath === currentPath) {
      break;
    }
    currentPath = parentPath;
  }
  return void 0;
};
const groupByCommonNearestFile = (paths, filename) => {
  return groupBy(paths, (path) => findNearestFile(filename, path));
};
const SHEBANG_SEQUENCE = "#!";
const SHELL_SHEBANG = "#!/usr/bin/env sh";
const NODE_SHEBANG = "#!/usr/bin/env node";
const TSNODE_SHEBANG = "#!/usr/bin/env node --require ts-node/register";
const shebangs = {
  [".js"]: NODE_SHEBANG,
  [".cjs"]: NODE_SHEBANG,
  [".mjs"]: NODE_SHEBANG,
  [".ts"]: TSNODE_SHEBANG,
  [".mts"]: TSNODE_SHEBANG,
  [".cts"]: TSNODE_SHEBANG,
  [".sh"]: SHELL_SHEBANG
};
const toAbsolute = (path, rawOptions) => {
  const options = normalizeCwdOption(rawOptions);
  return isAbsolute(path) ? path : join(options.cwd, path);
};
const normalizeTurnIntoExecutableOptions = (options) => {
  return {
    ...normalizeCwdOption(options),
    ...normalizeLoggerOption(options)
  };
};
const turnIntoExecutable = async (file, rawOptions) => {
  const options = normalizeTurnIntoExecutableOptions(rawOptions);
  const filePath = toAbsolute(file, options);
  const fileStats = await lstat(filePath).catch(() => void 0);
  if (!fileStats) {
    options.logger.error(`can't turn ${file} into executable, doesn't exist in ${options.cwd}`);
    return;
  } else if (!fileStats.isFile()) {
    options.logger.error(`can't turn ${file} into executable, not a file`);
    return;
  }
  const extension = extname(filePath);
  const shebang = shebangs[extension];
  if (shebang) {
    try {
      const rawFile = await readFile(filePath, {
        encoding: "utf8"
      });
      if (!rawFile.startsWith(SHEBANG_SEQUENCE)) {
        const rawFileWithShebang = `${shebang}

${rawFile}`;
        await writeFile(filePath, rawFileWithShebang).then(() => {
          options.logger.info(`prefixed ${file} with shebang: ${shebang}`);
        });
      }
    } catch (error) {
      options.logger.error("can't prepend file with shebang", error);
    }
  }
  if (!(fileStats.mode & 73)) {
    await chmod(filePath, 484).then(() => {
      options.logger.info(`marked ${file} as executable`);
    }).catch((error) => {
      options.logger.error(`cannot chmod ${file}, error:`, error);
    });
  }
};
const NEWLINE = /\r?\n/;
const WHITESPACE = /\s+/;
const DOUBLE_NEWLINE = /\r?\n\r?\n/;
const HASH_COMMENT = /#.*$/;
const readJson = async (path, options) => {
  if (path === void 0) {
    return void 0;
  }
  const rawJson = await readFile(path, {
    encoding: "utf8"
  }).catch((error) => {
    options?.logger?.error("error reading json", error);
    return void 0;
  });
  if (!rawJson) {
    return void 0;
  }
  try {
    return JSON.parse(rawJson);
  } catch {
    options?.logger?.error("error parsing json");
    return void 0;
  }
};
const normalizeWriteJsonOptions = (options) => {
  return {
    ...normalizeDryOption(options),
    ...normalizeLoggerOption(options),
    ...normalizeCwdOption(options),
    autoPrettier: options?.autoPrettier ?? true
  };
};
const writeJson = async (data, path, rawOptions) => {
  const options = normalizeWriteJsonOptions(rawOptions);
  let content = JSON.stringify(data, void 0, 2);
  if (options.autoPrettier) {
    content = await tryPrettify(content, { ...options, parser: "json-stringify" });
  }
  if (!options.dry) {
    await writeFile(path, content);
  }
};
const readYaml = async (path) => {
  if (path === void 0) {
    return void 0;
  }
  const rawYaml = await readFile(path, {
    encoding: "utf8"
  }).catch((error) => {
    console.error("error reading yaml", error);
    return void 0;
  });
  if (!rawYaml) {
    return void 0;
  }
  const result = load(rawYaml);
  if (typeof result === "string") {
    return void 0;
  }
  return result;
};
export {
  DOUBLE_NEWLINE,
  HASH_COMMENT,
  NEWLINE,
  NODE_SHEBANG,
  SHEBANG_SEQUENCE,
  SHELL_SHEBANG,
  TSNODE_SHEBANG,
  WHITESPACE,
  findNearestFile,
  getPrettierFormatter,
  groupByCommonNearestFile,
  normalizeCwdOption,
  normalizeDirectoryDepthOption,
  normalizePrettifyOptions,
  normalizeTurnIntoExecutableOptions,
  normalizeWriteJsonOptions,
  readJson,
  readYaml,
  shebangs,
  toAbsolute,
  tryPrettify,
  turnIntoExecutable,
  writeJson
};
