"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const common = require("@alexaegis/common");
const logging = require("@alexaegis/logging");
const node_fs = require("node:fs");
const node_path = require("node:path");
const promises = require("node:fs/promises");
const jsYaml = require("js-yaml");
const normalizeCwdOption = (options) => {
  return {
    cwd: options?.cwd ?? process.cwd()
  };
};
const normalizePrettifyOptions = (options) => {
  return {
    ...normalizeCwdOption(options),
    ...logging.normalizeLoggerOption(options),
    ...common.normalizeDryOption(options),
    parser: options?.parser ?? "babel"
  };
};
const getPrettierFormatter = async (rawOptions) => {
  const options = normalizePrettifyOptions(rawOptions);
  try {
    const prettier = await import("prettier");
    const prettierConfig = await prettier.resolveConfig(options.cwd, {
      editorconfig: true
    });
    const prettierOptions = {
      ...prettierConfig,
      parser: options.parser
    };
    return async (content) => {
      try {
        return await prettier.format(content, prettierOptions);
      } catch (error) {
        options.logger.error("prettier format failed", error);
        return content;
      }
    };
  } catch (error) {
    options.logger.warn("loading prettier failed", error);
    return (content) => content;
  }
};
const tryPrettify = async (content, options) => {
  const formatter = await getPrettierFormatter(options);
  return await formatter(content);
};
const normalizeDirectoryDepthOption = (options) => {
  return {
    depth: options?.depth ?? Number.POSITIVE_INFINITY
  };
};
const findNearestFile = (fileName, relativeTo = process.cwd()) => {
  let currentPath = relativeTo;
  for (; ; ) {
    if (node_fs.existsSync(node_path.join(currentPath, fileName))) {
      return currentPath;
    }
    const parentPath = node_path.join(currentPath, "..");
    if (parentPath === currentPath) {
      break;
    }
    currentPath = parentPath;
  }
  return void 0;
};
const groupByCommonNearestFile = (paths, filename) => {
  return common.groupBy(paths, (path) => findNearestFile(filename, path));
};
const SHEBANG_SEQUENCE = "#!";
const SHELL_SHEBANG = "#!/usr/bin/env sh";
const NODE_SHEBANG = "#!/usr/bin/env node";
const TSNODE_SHEBANG = "#!/usr/bin/env node --require ts-node/register";
const shebangs = {
  [".js"]: NODE_SHEBANG,
  [".cjs"]: NODE_SHEBANG,
  [".mjs"]: NODE_SHEBANG,
  [".ts"]: TSNODE_SHEBANG,
  [".mts"]: TSNODE_SHEBANG,
  [".cts"]: TSNODE_SHEBANG,
  [".sh"]: SHELL_SHEBANG
};
const toAbsolute = (path, rawOptions) => {
  const options = normalizeCwdOption(rawOptions);
  return node_path.isAbsolute(path) ? path : node_path.join(options.cwd, path);
};
const normalizeTurnIntoExecutableOptions = (options) => {
  return {
    ...normalizeCwdOption(options),
    ...logging.normalizeLoggerOption(options)
  };
};
const turnIntoExecutable = async (file, rawOptions) => {
  const options = normalizeTurnIntoExecutableOptions(rawOptions);
  const filePath = toAbsolute(file, options);
  const fileStats = await promises.lstat(filePath).catch(() => void 0);
  if (!fileStats) {
    options.logger.error(`can't turn ${file} into executable, doesn't exist in ${options.cwd}`);
    return;
  } else if (!fileStats.isFile()) {
    options.logger.error(`can't turn ${file} into executable, not a file`);
    return;
  }
  const extension = node_path.extname(filePath);
  const shebang = shebangs[extension];
  if (shebang) {
    try {
      const rawFile = await promises.readFile(filePath, {
        encoding: "utf8"
      });
      if (!rawFile.startsWith(SHEBANG_SEQUENCE)) {
        const rawFileWithShebang = `${shebang}

${rawFile}`;
        await promises.writeFile(filePath, rawFileWithShebang).then(() => {
          options.logger.info(`prefixed ${file} with shebang: ${shebang}`);
        });
      }
    } catch (error) {
      options.logger.error("can't prepend file with shebang", error);
    }
  }
  if (!(fileStats.mode & 73)) {
    await promises.chmod(filePath, 484).then(() => {
      options.logger.info(`marked ${file} as executable`);
    }).catch((error) => {
      options.logger.error(`cannot chmod ${file}, error:`, error);
    });
  }
};
const NEWLINE = /\r?\n/;
const WHITESPACE = /\s+/;
const DOUBLE_NEWLINE = /\r?\n\r?\n/;
const HASH_COMMENT = /#.*$/;
const readJson = async (path, options) => {
  if (path === void 0) {
    return void 0;
  }
  const rawJson = await promises.readFile(path, {
    encoding: "utf8"
  }).catch((error) => {
    options?.logger?.error("error reading json", error);
    return void 0;
  });
  if (!rawJson) {
    return void 0;
  }
  try {
    return JSON.parse(rawJson);
  } catch {
    options?.logger?.error("error parsing json");
    return void 0;
  }
};
const normalizeWriteJsonOptions = (options) => {
  return {
    ...common.normalizeDryOption(options),
    ...logging.normalizeLoggerOption(options),
    ...normalizeCwdOption(options),
    autoPrettier: options?.autoPrettier ?? true
  };
};
const writeJson = async (data, path, rawOptions) => {
  const options = normalizeWriteJsonOptions(rawOptions);
  let content = JSON.stringify(data, void 0, 2);
  if (options.autoPrettier) {
    content = await tryPrettify(content, { ...options, parser: "json-stringify" });
  }
  if (!options.dry) {
    await promises.writeFile(path, content);
  }
};
const readYaml = async (path) => {
  if (path === void 0) {
    return void 0;
  }
  const rawYaml = await promises.readFile(path, {
    encoding: "utf8"
  }).catch((error) => {
    console.error("error reading yaml", error);
    return void 0;
  });
  if (!rawYaml) {
    return void 0;
  }
  const result = jsYaml.load(rawYaml);
  if (typeof result === "string") {
    return void 0;
  }
  return result;
};
exports.DOUBLE_NEWLINE = DOUBLE_NEWLINE;
exports.HASH_COMMENT = HASH_COMMENT;
exports.NEWLINE = NEWLINE;
exports.NODE_SHEBANG = NODE_SHEBANG;
exports.SHEBANG_SEQUENCE = SHEBANG_SEQUENCE;
exports.SHELL_SHEBANG = SHELL_SHEBANG;
exports.TSNODE_SHEBANG = TSNODE_SHEBANG;
exports.WHITESPACE = WHITESPACE;
exports.findNearestFile = findNearestFile;
exports.getPrettierFormatter = getPrettierFormatter;
exports.groupByCommonNearestFile = groupByCommonNearestFile;
exports.normalizeCwdOption = normalizeCwdOption;
exports.normalizeDirectoryDepthOption = normalizeDirectoryDepthOption;
exports.normalizePrettifyOptions = normalizePrettifyOptions;
exports.normalizeTurnIntoExecutableOptions = normalizeTurnIntoExecutableOptions;
exports.normalizeWriteJsonOptions = normalizeWriteJsonOptions;
exports.readJson = readJson;
exports.readYaml = readYaml;
exports.shebangs = shebangs;
exports.toAbsolute = toAbsolute;
exports.tryPrettify = tryPrettify;
exports.turnIntoExecutable = turnIntoExecutable;
exports.writeJson = writeJson;
