import type { Logger } from '@alexaegis/logging';
import type { PackageJson, WorkspacePackage } from '@alexaegis/workspace-tools';
import type { LibraryFormats } from 'vite';
import { type PackageJsonKindType } from '../package-json/package-json-kind.enum.js';
import { AutoBin } from '../plugins/bin/auto-bin.class.js';
import { AutoCopyLicense } from '../plugins/copy-license/auto-copy-license.class.js';
import { AutoDirective } from '../plugins/directive/auto-directive.class.js';
import { AutoExportStatic } from '../plugins/export-static/auto-export-static.class.js';
import { AutoExport } from '../plugins/export/auto-export.class.js';
import { AutoMetadata } from '../plugins/metadata/auto-metadata.class.js';
import type { PackageExaminationResult } from '../plugins/pakk-feature.type.js';
import { AutoPeer } from '../plugins/peer/auto-peer.class.js';
import { AutoSort } from '../plugins/sort-package-json/auto-sort-package-json.class.js';
import { type NormalizedPakkContext, type NormalizedPakkOptions, type PakkContext, type PakkOptions } from './pakk.class.options.js';
export declare const createIsFeatureEnabled: (enabledFeatures: PakkFeatureName[], disabledFeatures: PakkFeatureName[]) => (feature: PakkFeatureName) => boolean;
export declare const pakkFeatureMap: {
    readonly bin: typeof AutoBin;
    readonly 'copy-license': typeof AutoCopyLicense;
    readonly export: typeof AutoExport;
    readonly 'export-static': typeof AutoExportStatic;
    readonly metadata: typeof AutoMetadata;
    readonly peer: typeof AutoPeer;
    readonly sort: typeof AutoSort;
    readonly directive: typeof AutoDirective;
};
export declare const pakkFeatures: ("bin" | "sort" | "copy-license" | "export" | "export-static" | "metadata" | "peer" | "directive")[];
export type PakkFeatureName = keyof typeof pakkFeatureMap;
/**
 * This class does not execute anything on it's own, just provides itself as a
 * tool that then needs to be orchestrated by antoher tool. This could be
 * the standalone runner or the vite plugin. It also does not hold state,
 * the packageJson object that is being worked on has to be stored elsewhere
 * to avoid inner mutation.
 */
export declare class Pakk {
    readonly options: NormalizedPakkOptions;
    readonly context: NormalizedPakkContext;
    private features;
    private constructor();
    getLogger(): Logger<unknown>;
    getTargetPackageJsonKinds(): PackageJsonKindType[];
    static withContext(manualContext: Pick<PakkContext, 'formats' | 'fileName'>, rawOptions?: PakkOptions | undefined): Promise<Pakk>;
    static primaryLibraryFormat(packageJson: PackageJson): LibraryFormats;
    /**
     * 1st step, examining the package. This step does not write anything.
     * It can be done before the build takes place as it's only supposed to
     * take a look at your source code.
     */
    examinePackage(workspacePackage?: WorkspacePackage): Promise<PackageExaminationResult>;
    /**
     * Will return a path adjusted packageJson object based on the content of
     * the workspace for both the SOURCE and DISTRIBUTION packageJson files.
     *
     * And also returns the path where it should be written to.
     */
    createUpdatedPackageJson(packageJsonKind: PackageJsonKindType): Promise<{
        updatedPackageJson: PackageJson;
        path: string;
    }>;
}
//# sourceMappingURL=pakk.class.d.ts.map