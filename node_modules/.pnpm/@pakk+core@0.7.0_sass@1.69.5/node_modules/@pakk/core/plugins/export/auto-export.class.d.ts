import type { PackageJson } from '@alexaegis/workspace-tools';
import type { PackageExaminationResult, PakkFeature } from '../pakk-feature.type.js';
import type { InternalModuleFormat } from 'rollup';
import type { LibraryFormats } from 'vite';
import type { NormalizedPakkContext } from '../../internal/pakk.class.options.js';
import { type PackageJsonKindType, type PathMap } from '../../package-json/index.js';
import { type AutoExportOptions } from './auto-export.class.options.js';
export declare const allExportPathCombinations: readonly ["development-to-source", "development-to-dist", "distribution-to-dist"];
export type AllExportPathCombinations = (typeof allExportPathCombinations)[number];
export type ExportPathMap = PathMap<AllExportPathCombinations>;
export type ExportTargetFileFormats = LibraryFormats;
export interface PackageExportPathContext {
    /**
     * When 'packageJsonKind' is set to DEVELOPMENT and this context is used
     * to calculate the paths towards the source files, 'formats' and
     * 'fileNameFn' are not used.
     */
    packageJsonKind: PackageJsonKindType;
    /**
     * The kind of files an export can point to. It's used to guess/calculate how
     * the fileName will change once it ends up in the outDir after building.
     * If it's undefined it will not do any renaming and will use the source name.
     * Useful when targeting the source or for files that are not being renamed
     * during processing like .svelte files.
     *
     * ? Out of InternalModuleFormat it really is only LibaryFormats that we care about
     */
    format: InternalModuleFormat;
}
/**
 * Generates exports entries automatically
 */
export declare class AutoExport implements PakkFeature {
    readonly order = 1;
    private readonly options;
    private readonly context;
    private exportMap;
    constructor(context: NormalizedPakkContext, options?: AutoExportOptions);
    examinePackage(_packageJson: PackageJson): Promise<Partial<PackageExaminationResult>>;
    /**
     * This plugin compiles the exports object for a packageJson file
     *
     * For the distributed packageJson it should always contain paths that are
     * targeting the dist folder from the dist folder.
     *
     * For development packageJson the types always target the source for
     * immediate feedback by the LSP by local consumers of the package.
     * The actual code that's being imported by node has two options,
     * by default they target the outDir and expect libraries to be built
     * before actually running them in a local setting.
     * There's an alternative mode however that will target the source files.
     */
    process(_packageJson: PackageJson, pathContext: PackageExportPathContext): PackageJson;
}
//# sourceMappingURL=auto-export.class.d.ts.map