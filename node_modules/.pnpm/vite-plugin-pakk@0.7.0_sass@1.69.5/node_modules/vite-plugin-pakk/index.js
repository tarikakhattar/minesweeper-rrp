import { asyncFilterMap } from "@alexaegis/common";
import { writeJson, toAbsolute, readJson, getPrettierFormatter } from "@alexaegis/fs";
import { normalizePakkOptions, DEFAULT_EXPORT_FORMATS, Pakk } from "@pakk/core";
import { join } from "node:path";
import dts from "vite-plugin-dts";
import { collectFileDirnamePathsUpDirectoryTree, PACKAGE_JSON_NAME } from "@alexaegis/workspace-tools";
import { readFileSync } from "node:fs";
import { builtinModules } from "node:module";
import { writeFile } from "node:fs/promises";
const createRollupExternalsFn = (...packageJsons) => {
  const dependencyNames = [];
  for (const packageJson of packageJsons) {
    if (packageJson.dependencies) {
      dependencyNames.push(...Object.keys(packageJson.dependencies));
    }
    if (packageJson.devDependencies) {
      dependencyNames.push(...Object.keys(packageJson.devDependencies));
    }
    if (packageJson.peerDependencies) {
      dependencyNames.push(...Object.keys(packageJson.peerDependencies));
    }
    if (packageJson.optionalDependencies) {
      dependencyNames.push(...Object.keys(packageJson.optionalDependencies));
    }
  }
  return (source, _importer, _isResolved) => {
    return dependencyNames.some((dep) => source === dep || source.startsWith(dep + "/")) || builtinModules.includes(source) || source.startsWith("node:");
  };
};
const createLazyAutoExternalsFunction = () => {
  let externalsFn;
  return (source, importer, isResolved) => {
    if (!externalsFn) {
      externalsFn = createRollupExternalsFn(
        ...collectFileDirnamePathsUpDirectoryTree(PACKAGE_JSON_NAME, {
          maxPackages: 2
        }).map(
          (path) => JSON.parse(
            readFileSync(join(path, PACKAGE_JSON_NAME), { encoding: "utf8" })
          )
        )
      );
    }
    return externalsFn(source, importer, isResolved);
  };
};
const pakk = (rawOptions) => {
  let pakk2;
  const options = normalizePakkOptions(rawOptions);
  const pakkPlugin = {
    name: "pakk",
    apply: "build",
    config: async (config) => {
      const startTime = performance.now();
      const formats = config.build?.lib && config.build.lib.formats ? config.build.lib.formats : DEFAULT_EXPORT_FORMATS;
      const outDir = config.build?.outDir ?? options.outDir;
      pakk2 = await Pakk.withContext(
        {
          formats,
          fileName: config.build?.lib && typeof config.build.lib.fileName === "function" ? config.build.lib.fileName : void 0
        },
        {
          ...options,
          outDir
        }
      );
      options.logger.info(
        "examining workspace package at",
        pakk2.context.workspacePackage.packageJsonPath
      );
      options.logger.trace("initial vite config", config);
      if (config.build?.lib && !!config.build.lib.entry) {
        options.logger.info("build.lib.entry is defined in vite config, will be ignored!");
        config.build.lib.entry = {};
      }
      if (config.build?.outDir && rawOptions?.outDir) {
        options.logger.info(
          `vite plugin defines build.outDir as "${config.build.outDir}". Using that over "${rawOptions.outDir}"`
        );
      }
      const examinationResult = await pakk2.examinePackage();
      options.logger.trace("examination result", examinationResult);
      options.logger.trace("outDir", outDir);
      const viteConfigUpdates = {
        build: {
          target: config.build?.target ?? "es2022",
          minify: config.build?.minify ?? false,
          sourcemap: config.build?.sourcemap ?? false,
          outDir,
          rollupOptions: {
            external: config.build?.rollupOptions?.external ?? createLazyAutoExternalsFunction(),
            treeshake: config.build?.rollupOptions?.treeshake ?? true
          },
          lib: {
            formats: pakk2.context.formats,
            entry: examinationResult.bundlerEntryFiles
            // The entry has to be an array to keep the file's names in the output directory too.
          }
        }
      };
      options.logger.info(
        `preparation phase took ${Math.floor(performance.now() - startTime)}ms to finish`
      );
      return viteConfigUpdates;
    },
    closeBundle: async () => {
      options.logger.info(
        "processing workspace package at",
        pakk2.context.workspacePackage.packageJsonPath
      );
      const startTime = performance.now();
      await asyncFilterMap(pakk2.getTargetPackageJsonKinds(), async (packageJsonTarget) => {
        const { updatedPackageJson, path } = await pakk2.createUpdatedPackageJson(packageJsonTarget);
        options.logger.info("writing updated package.json to", path);
        await writeJson(updatedPackageJson, path, {
          autoPrettier: pakk2.options.autoPrettier,
          dry: pakk2.options.dry
        });
      });
      options.logger.info(
        `update phase took ~${Math.floor(performance.now() - startTime)}ms to finish`
      );
    }
  };
  const plugins = [pakkPlugin];
  if (options.dts) {
    plugins.push(
      dts({
        copyDtsFiles: true,
        cleanVueFileName: true,
        entryRoot: join(options.srcDir, options.exportBaseDir)
      })
    );
  }
  return plugins;
};
const updatePackageJsonPlugin = (options) => ({
  name: "update-package-json",
  apply: "build",
  buildEnd: async (error) => {
    if (!error) {
      const cwd = options.cwd ?? process.cwd();
      const packageJsonLocation = toAbsolute(options.filename ?? PACKAGE_JSON_NAME, { cwd });
      const packageJson = await readJson(packageJsonLocation);
      if (!packageJson) {
        console.warn(
          `updatePackageJsonPlugin didn't find packageJson at ${packageJsonLocation}!`
        );
        return;
      }
      const augmentedPackageJson = options.updater(packageJson);
      let rawAugmentedPackageJson = JSON.stringify(augmentedPackageJson);
      if (options.autoPrettier ?? true) {
        const formatter = await getPrettierFormatter({
          parser: "json-stringify",
          cwd
        });
        rawAugmentedPackageJson = await formatter(rawAugmentedPackageJson);
      }
      await writeFile(packageJsonLocation, rawAugmentedPackageJson);
    }
  }
});
export {
  createLazyAutoExternalsFunction,
  createRollupExternalsFn,
  pakk,
  updatePackageJsonPlugin
};
//# sourceMappingURL=index.js.map
