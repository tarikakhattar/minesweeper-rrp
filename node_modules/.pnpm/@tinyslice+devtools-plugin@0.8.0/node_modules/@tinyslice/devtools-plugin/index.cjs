"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const rxjs = require("rxjs");
const DEFAULT_DEVTOOLS_OPTIONS = {
  name: "TinySlice"
};
const jsonUndefinedReplacer = (_key, value) => value ?? null;
const normalizeUndefined = (obj) => {
  const stringified = JSON.stringify(obj, jsonUndefinedReplacer);
  return JSON.parse(stringified);
};
class TinySliceDevtoolPlugin {
  constructor(options) {
    this.options = options;
    this.extension = TinySliceDevtoolPlugin.getExtension();
  }
  extension;
  extensionConnection;
  sink = new rxjs.Subscription();
  unsubscribeStateInjector;
  hooks;
  committedState;
  lastState;
  initialState;
  actionId = 0;
  actions = {};
  actionsTurnedOff = /* @__PURE__ */ new Set();
  additionalTriggers = [];
  registerAdditionalTrigger = (trigger) => {
    this.additionalTriggers.push(trigger);
  };
  register = (hooks) => {
    this.hooks = hooks;
    this.initialState = JSON.stringify(normalizeUndefined(hooks.initialState));
  };
  onError = (error) => {
    console.log("Error from store:", error);
  };
  connect(connection) {
    this.lastState = this.initialState ? JSON.parse(this.initialState) : void 0;
    this.committedState = this.initialState;
    connection.init(this.lastState);
    this.sink.add(
      this.hooks.state$.pipe(
        rxjs.tap(({ actionPacket, nextState }) => {
          this.lastState = normalizeUndefined(nextState);
          this.actions[this.actionId] = actionPacket;
          this.actionId += 1;
          connection.send(actionPacket, this.lastState);
        })
      ).subscribe()
    );
    this.unsubscribeStateInjector = connection.subscribe((message) => {
      if (message.type === "DISPATCH") {
        switch (message.payload?.type) {
          case "JUMP_TO_ACTION": {
            this.hooks.stateInjector(JSON.parse(message.state));
            break;
          }
          case "COMMIT": {
            console.log("COMMIT", this.lastState);
            if (this.lastState) {
              connection.init(this.lastState);
              this.committedState = JSON.stringify(this.lastState);
            } else {
              connection.error("Nothing to commit");
            }
            break;
          }
          case "ROLLBACK": {
            if (this.committedState) {
              const parsedCommittedState = JSON.parse(this.committedState);
              connection.init(parsedCommittedState);
              this.hooks.stateInjector(parsedCommittedState);
            } else {
              connection.error("No commit to rollback to");
            }
            break;
          }
          case "RESET": {
            const initialState = JSON.parse(this.initialState);
            this.hooks.stateInjector(initialState);
            connection.init(initialState);
            break;
          }
          case "IMPORT_STATE": {
            const computedStates = message.payload.nextLiftedState.computedStates;
            const actions = Object.values(message.payload.nextLiftedState.actionsById);
            const lastState = computedStates[actions.length - 1]?.state;
            for (const [index, action] of actions.entries()) {
              const state = computedStates[index];
              if (state) {
                if (action.action.type === "@@INIT") {
                  connection.init(state.state);
                } else {
                  connection.send(action.action, state.state);
                }
              }
            }
            if (lastState) {
              this.hooks.stateInjector(lastState);
            }
            break;
          }
          case "TOGGLE_ACTION": {
            if (this.actionsTurnedOff.has(message.payload.id)) {
              this.actionsTurnedOff.delete(message.payload.id);
            } else {
              this.actionsTurnedOff.add(message.payload.id);
            }
            break;
          }
        }
      }
      for (const trigger of this.additionalTriggers)
        trigger();
    });
  }
  disconnect() {
    this.extension?.disconnect();
  }
  start = () => {
    this.extensionConnection = this.extension?.connect({
      ...DEFAULT_DEVTOOLS_OPTIONS,
      ...this.options
    });
    if (this.extensionConnection) {
      this.connect(this.extensionConnection);
    }
  };
  stop = () => {
    this.sink.unsubscribe();
    this.unsubscribeStateInjector?.();
    this.extensionConnection?.unsubscribe();
    if (this.extensionConnection) {
      this.disconnect();
    }
    this.sink = new rxjs.Subscription();
  };
  error(error) {
    this.extensionConnection?.error(error);
  }
  static getExtension() {
    return globalThis.__REDUX_DEVTOOLS_EXTENSION__;
  }
}
exports.DEFAULT_DEVTOOLS_OPTIONS = DEFAULT_DEVTOOLS_OPTIONS;
exports.TinySliceDevtoolPlugin = TinySliceDevtoolPlugin;
