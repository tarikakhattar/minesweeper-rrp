import { fillStringWithTemplateVariables, fillObjectWithTemplateVariables, deepMerge, sortObject, dropKeys, groupBy, isNotNullish } from "@alexaegis/common";
import { tryPrettify, turnIntoExecutable, toAbsolute, readJson, writeJson } from "@alexaegis/fs";
import { getPackageJsonTemplateVariables, PACKAGE_JSON_DEPENDENCY_FIELDS } from "@alexaegis/workspace-tools";
import { getAssumedFinalInstallLocationOfPackage, isManagedFile } from "autotool-plugin";
import { readFile, mkdir, writeFile, rm, symlink } from "node:fs/promises";
import { relative, join, dirname, extname, basename, normalize } from "node:path";
import "prettier";
import { createJsonSortingPreferenceNormalizer } from "@alexaegis/workspace-tools/sort";
import { relative as relative$1 } from "node:path/posix";
import { coerce, compareBuild } from "semver";
import { minimatch } from "minimatch";
const name = "autotool-plugin-default";
const description = "Default executors and validators for autotool";
const version = "0.3.0";
const license = "MIT";
const archetype = {
  platform: "node",
  language: "ts",
  kind: "lib"
};
const keywords = [
  "autotool",
  "autotool-plugin",
  "managed-by-autotool"
];
const type = "module";
const config = {
  "engine-strict": false
};
const publishConfig = {
  access: "public"
};
const scripts = {
  build: "turbo run build-lib_ --concurrency 16 --cache-dir .cache/turbo --filter autotool-plugin-default",
  "build-lib_": "vite build",
  "lint:depcheck": "turbo run lint:depcheck_ --concurrency 16 --cache-dir .cache/turbo --filter autotool-plugin-default",
  "lint:depcheck_": "depcheck",
  "lint:es": "turbo run lint:es_ --concurrency 16 --cache-dir .cache/turbo --filter autotool-plugin-default",
  "lint:es_": "eslint --max-warnings=0 --fix --no-error-on-unmatched-pattern .",
  "lint:format": "turbo run lint:format_ --concurrency 16 --cache-dir .cache/turbo --filter autotool-plugin-default",
  "lint:format_": "prettier --cache-location .cache/prettier --plugin prettier-plugin-svelte --plugin prettier-plugin-tailwindcss --check .",
  "lint:md": "turbo run lint:md_ --concurrency 16 --cache-dir .cache/turbo --filter autotool-plugin-default",
  "lint:md_": "remark --frail --no-stdout --silently-ignore .",
  "lint:tsc": "turbo run lint:tsc_ --concurrency 16 --cache-dir .cache/turbo --filter autotool-plugin-default",
  "lint:tsc_": "tsc --noEmit",
  publint: "BUILD_REASON='publish' turbo run publint_ --concurrency 16 --cache-dir .cache/turbo --filter autotool-plugin-default",
  publint_: "publint dist",
  all: "BUILD_REASON='publish' turbo run all_ --concurrency 16 --cache-dir .cache/turbo --filter autotool-plugin-default",
  format: "turbo run format_ --concurrency 16 --cache-dir .cache/turbo --filter autotool-plugin-default",
  format_: "prettier --cache-location .cache/prettier --plugin prettier-plugin-svelte --plugin prettier-plugin-tailwindcss --write .",
  test: "turbo run test_ --concurrency 16 --cache-dir .cache/turbo --filter autotool-plugin-default",
  test_: "vitest --passWithNoTests --coverage --run",
  "test:watch": "vitest --passWithNoTests --coverage"
};
const exports = {
  ".": {
    types: "./src/index.ts",
    "import": "./dist/index.js",
    require: "./dist/index.cjs",
    "default": "./dist/index.js"
  },
  "./readme": "./readme.md"
};
const dependencies = {
  "@alexaegis/common": "^0.7.0",
  "@alexaegis/fs": "^0.7.0",
  "@alexaegis/logging": "^0.7.0",
  "@alexaegis/workspace-tools": "^0.7.0",
  "autotool-plugin": "^0.3.0",
  minimatch: "^9.0.3",
  semver: "^7.5.4"
};
const devDependencies = {
  "@alexaegis/eslint-config-vitest": "^0.8.1",
  "@alexaegis/ts": "^0.8.1",
  "@alexaegis/vite": "^0.8.1",
  "@alexaegis/vitest": "^0.8.1",
  "@schemastore/package": "^0.0.10",
  "@types/node": "^20.5.8",
  "@types/semver": "^7.5.1",
  publint: "^0.2.2",
  typescript: "^5.2.2",
  vite: "^4.4.9",
  vitest: "^0.34.3"
};
const packageJson = {
  name,
  description,
  version,
  license,
  "private": false,
  archetype,
  keywords,
  type,
  config,
  publishConfig,
  scripts,
  exports,
  dependencies,
  devDependencies
};
const autotoolElementCustomExecutor = {
  type: "custom",
  execute: async (element, target, options) => {
    await element.apply(element, target, options);
  }
};
const guessPrettierParser = (path) => {
  const extension = extname(path);
  switch (extension) {
    case ".json": {
      return "json";
    }
    case ".ts": {
      return "typescript";
    }
    case ".yml":
    case ".yaml": {
      return "yaml";
    }
    default: {
      return "babel";
    }
  }
};
const autotoolElementFileCopyExecutor = {
  type: "fileCopy",
  execute: async (element, target, options) => {
    const templateVariables = getPackageJsonTemplateVariables(target.targetPackage.packageJson);
    templateVariables["relativePathFromPackageToRoot"] = relative(target.targetPackage.packagePath, target.rootPackage.packagePath) || ".";
    Object.assign(templateVariables, element.templateVariables);
    const sourcePackagePath = getAssumedFinalInstallLocationOfPackage(
      target.rootPackage,
      element.sourcePluginPackageName
    );
    const sourceFilePath = join(sourcePackagePath, element.sourceFile);
    options.logger.trace("Copy file from", sourceFilePath);
    const isSourceFileManaged = await isManagedFile(sourceFilePath);
    if (!isSourceFileManaged) {
      options.logger.warn(
        `File ${relative(
          target.rootPackage.packagePath,
          sourceFilePath
        )} is not managed, it won't be overwritten on the next run unless forced!`
      );
    }
    let fileContent = await readFile(sourceFilePath, { encoding: "utf8" }) || "";
    options.logger.silly("filecontent read from source file", sourceFilePath, fileContent);
    fileContent = element.transformers?.reduce(
      (content, transformer) => transformer(content),
      fileContent
    ) ?? fileContent;
    options.logger.silly("filecontent ran through transformers", fileContent);
    fileContent = fillStringWithTemplateVariables(fileContent, templateVariables);
    options.logger.silly("filecontent filled with template variables", fileContent);
    const prettierParser = element.formatWithPrettier;
    if (prettierParser) {
      fileContent = await tryPrettify(fileContent, {
        ...options,
        parser: prettierParser === true ? guessPrettierParser(target.targetFilePathAbsolute) : prettierParser
      });
    }
    options.logger.silly("filecontent formatted using prettier (first 50 char):", fileContent);
    if (options.dry) {
      options.logger.info("(Dry) Pretending to make sure target file has a directory...");
    } else {
      options.logger.info("Making sure target file has a directory...");
      await mkdir(dirname(target.targetFilePathAbsolute), { recursive: true });
    }
    if (options.dry) {
      options.logger.info(
        `(Dry) Pretending to copy ${element.sourceFile} to ${target.targetFilePackageRelative}...`
      );
      if (element.markAsExecutable) {
        options.logger.info(
          `(Dry) Pretending to mark ${target.targetFilePackageRelative} as executable...`
        );
      }
    } else {
      options.logger.info(
        `Copying ${element.sourceFile} to ${target.targetFilePackageRelative}...`
      );
      try {
        await writeFile(target.targetFilePathAbsolute, fileContent);
        if (element.markAsExecutable) {
          options.logger.info(
            `Marking ${target.targetFilePackageRelative} as executable...`
          );
          await turnIntoExecutable(target.targetFilePathAbsolute, options);
        }
      } catch (error) {
        options.logger.error("Error happened during execution!", error);
      }
    }
  }
};
const autotoolElementFileRemoveExecutor = {
  type: "fileRemove",
  conflictsOnTargetLevel: [autotoolElementFileCopyExecutor.type],
  execute: async (_element, target, options) => {
    try {
      if (options.dry) {
        options.logger.info(`(DRY) Removing ${target.targetFilePackageRelative}`);
      } else {
        options.logger.info(`Removing ${target.targetFilePackageRelative}...`);
        await rm(target.targetFilePathAbsolute);
      }
    } catch (error) {
      if (error.code === "ENOENT") {
        options.logger.info("nothing to remove");
      } else {
        options.logger.error("Failed to remove file!", error);
      }
    }
  },
  /**
   * If multiple elements try to remove the same element, just delete it once
   */
  consolidate: (elements) => elements[0]
};
const autotoolElementFileSymlinkExecutor = {
  type: "fileSymlink",
  execute: async (element, target, options) => {
    const sourcePackagePath = getAssumedFinalInstallLocationOfPackage(
      target.rootPackage,
      element.sourcePluginPackageName
    );
    const sourceFilePath = join(sourcePackagePath, element.sourceFile);
    options.logger.trace("Symlink file from", sourceFilePath);
    const isSourceFileManaged = await isManagedFile(sourceFilePath);
    if (!isSourceFileManaged) {
      options.logger.warn(
        `File ${relative(
          target.rootPackage.packagePath,
          sourceFilePath
        )} is not managed, it won't be overwritten on the next run unless forced!`
      );
    }
    const targetDir = dirname(target.targetFilePathAbsolute);
    if (options.dry) {
      options.logger.info("(Dry) Pretending to make sure target file has a directory...");
    } else {
      options.logger.info("Making sure target file has a directory...");
      await mkdir(targetDir, { recursive: true });
    }
    const relativeFromTargetBackToFile = relative(
      targetDir,
      toAbsolute(sourceFilePath, options)
    );
    if (options.dry) {
      options.logger.info(
        `(Dry) Pretending to create symlink at ${target.targetFilePath} to link to ${relativeFromTargetBackToFile} from the target!`
      );
    } else {
      await symlink(relativeFromTargetBackToFile, target.targetFilePathAbsolute);
      options.logger.info(
        `Created symlink at ${target.targetFilePath} to link to ${relativeFromTargetBackToFile} from the target!`
      );
    }
  }
};
const sortVersions = (versions) => {
  return versions.map((version2) => ({ version: version2, coercedVersion: coerce(version2) })).sort((a, b) => {
    if (a.coercedVersion && b.coercedVersion) {
      return compareBuild(a.coercedVersion, b.coercedVersion);
    } else if (a.version && b.version) {
      return a.coercedVersion ? -1 : 1;
    } else {
      return a.version ? 1 : -1;
    }
  }).map((v) => v.version ?? "*");
};
const getLargestVersion = (...versions) => {
  const sorted = sortVersions(versions);
  return sorted.pop() ?? "*";
};
const mergeDependencies = (a = {}, b = {}) => {
  const keys = [.../* @__PURE__ */ new Set([...Object.keys(a), ...Object.keys(b)])];
  return keys.reduce((acc, key) => {
    if ((!Object.hasOwn(b, key) || b[key] !== void 0) && (!Object.hasOwn(a, key) || a[key] !== void 0)) {
      acc[key] = getLargestVersion(a[key], b[key]);
    }
    return acc;
  }, {});
};
const autotoolElementJsonExecutor = {
  type: "packageJson",
  defaultTarget: "package.json",
  execute: async (element, target, options) => {
    const workspaceRoot = target.rootPackage.packagePath;
    const templateVariables = getPackageJsonTemplateVariables(target.targetPackage.packageJson);
    templateVariables["relativePathFromPackageToRoot"] = relative$1(target.targetPackage.packagePath, workspaceRoot) || ".";
    Object.assign(templateVariables, element.templateVariables);
    const packageJsonUpdates = fillObjectWithTemplateVariables(
      element.data,
      templateVariables
    );
    const packageJson2 = await readJson(target.targetFilePathAbsolute);
    options.logger.trace("UPDATES", packageJsonUpdates);
    options.logger.trace("packageJson[dependencyFieldKey]", packageJson2?.devDependencies);
    if (!packageJson2) {
      throw new Error("Can't read packageJson!");
    }
    const naivelyMerged = deepMerge([packageJson2, packageJsonUpdates], { dropKeys: false });
    const targetPackageJson = PACKAGE_JSON_DEPENDENCY_FIELDS.reduce(
      (acc, dependencyFieldKey) => {
        if (packageJsonUpdates[dependencyFieldKey]) {
          acc[dependencyFieldKey] = mergeDependencies(
            packageJson2[dependencyFieldKey],
            packageJsonUpdates[dependencyFieldKey]
          );
        }
        return acc;
      },
      naivelyMerged
    );
    const sortingPreferenceNormalizer = await createJsonSortingPreferenceNormalizer(
      basename(target.targetFilePath),
      { cwd: workspaceRoot }
    );
    try {
      if (options.dry) {
        options.logger.info(`pretending to update ${target.targetPackage.packageJsonPath}`);
      } else {
        options.logger.info(`updating ${target.targetPackage.packageJsonPath}`);
      }
      await writeJson(
        sortObject(
          dropKeys(targetPackageJson),
          sortingPreferenceNormalizer(element.sortingPreference)
        ),
        target.targetPackage.packageJsonPath,
        {
          dry: options.dry
        }
      );
    } catch (error) {
      options.logger.error(
        `can't write updates to ${target.targetPackage.packageJsonPath}, error happened:`,
        error
      );
    }
  },
  consolidate: (elements) => {
    const groupedByPass = groupBy(
      elements,
      (element) => element.consolidationPass ? element.consolidationPass.toString() : "0"
    );
    const elementsOrderedByPass = Object.entries(groupedByPass).map(([k, elements2]) => ({
      pass: Number.parseInt(k, 10),
      elements: elements2
    })).sort((a, b) => a.pass - b.pass).flatMap((e) => e.elements);
    const baseElement = elementsOrderedByPass[0];
    const mergedData = deepMerge(
      elementsOrderedByPass.map((element) => element.data),
      {
        dropKeys: false
      }
    );
    return baseElement ? {
      ...baseElement,
      data: mergedData
    } : void 0;
  }
};
const validateThereAreNoMultipleCopyAndRemoveElementsOnTheSameTarget = (workspacePackageElementsByTarget) => {
  return Object.entries(workspacePackageElementsByTarget.targetedElementsByFile).map(([targetFile, packageElements]) => {
    const copyAndSymlinkElements = packageElements.filter(
      (packageElement) => packageElement.element.executor === "fileCopy" || packageElement.element.executor === "fileSymlink"
    );
    const packageJsonElements = packageElements.filter(
      (packageElement) => packageElement.element.executor === "packageJson"
    );
    const normalizedPackageJsonElementCount = Math.min(packageJsonElements.length, 1);
    const fileRemoveElements = packageElements.filter(
      (packageElement) => packageElement.element.executor === "fileRemove"
    );
    const normalizedRemoveElementCount = Math.min(fileRemoveElements.length, 1);
    const elementCountAfterConsolidate = normalizedPackageJsonElementCount + normalizedRemoveElementCount + copyAndSymlinkElements.length;
    return elementCountAfterConsolidate > 1 ? {
      code: "EOVERWRITE",
      message: `There are more than one elements trying to copy to or remove "${targetFile}"`,
      targetFile,
      sourceElements: copyAndSymlinkElements.map(
        (packageElement) => packageElement.element
      ),
      sourcePlugins: copyAndSymlinkElements.flatMap((packageElement) => packageElement.sourcePlugin).filter(isNotNullish)
    } : void 0;
  }).filter(isNotNullish);
};
const validateRootElementNotModifyingPackages = (workspacePackageElementsByTarget) => {
  const errors = [];
  if (workspacePackageElementsByTarget.workspacePackage.packageKind === "root") {
    const workspacePackagePatterns = workspacePackageElementsByTarget.workspacePackage.workspacePackagePatterns;
    const elementsTargetingInsideAPackage = Object.entries(
      workspacePackageElementsByTarget.targetedElementsByFile
    ).flatMap(([target, elements]) => {
      return workspacePackagePatterns.some((pattern) => minimatch(target, pattern + "/**")) ? elements.map((element) => ({ element, target })) : [];
    });
    if (elementsTargetingInsideAPackage.length > 0) {
      errors.push(
        ...elementsTargetingInsideAPackage.map(
          (elementTargetingInsideAPackage) => ({
            code: "ETRYINGTOMODIFYPKGFROMROOT",
            message: "A workspace level element tries to modify a a sub-package!",
            workspacePackage: workspacePackageElementsByTarget.workspacePackage,
            targetFile: elementTargetingInsideAPackage.target,
            sourceElements: [elementTargetingInsideAPackage.element.element],
            sourcePlugins: elementTargetingInsideAPackage.element.sourcePlugin ? [elementTargetingInsideAPackage.element.sourcePlugin] : []
          })
        )
      );
    }
  }
  return errors;
};
const getErrorSourcesFromPackageElement = (packageElements) => {
  return {
    sourceElements: packageElements.map((packageElement) => packageElement.element),
    sourcePlugins: packageElements.flatMap((packageElement) => packageElement.sourcePlugin).filter(isNotNullish)
  };
};
const validateTargetsAreNotOutsideOfPackage = (workspacePackageElementsByTarget) => {
  return Object.entries(workspacePackageElementsByTarget.targetedElementsByFile).filter(([targetFile]) => normalize(targetFile).startsWith("..")).map(([targetFile, packageElements]) => ({
    code: "ETARGETISOUTSIDE",
    message: `Target ${targetFile} is pointing outside of the package!`,
    targetFile,
    ...getErrorSourcesFromPackageElement(packageElements)
  }));
};
const defaultPlugin = {
  name: packageJson.name,
  executors: {
    fileCopy: autotoolElementFileCopyExecutor,
    fileRemove: autotoolElementFileRemoveExecutor,
    fileSymlink: autotoolElementFileSymlinkExecutor,
    packageJson: autotoolElementJsonExecutor,
    custom: autotoolElementCustomExecutor
  },
  validators: [
    validateTargetsAreNotOutsideOfPackage,
    validateRootElementNotModifyingPackages,
    validateThereAreNoMultipleCopyAndRemoveElementsOnTheSameTarget
  ]
};
export {
  defaultPlugin as default,
  defaultPlugin
};
