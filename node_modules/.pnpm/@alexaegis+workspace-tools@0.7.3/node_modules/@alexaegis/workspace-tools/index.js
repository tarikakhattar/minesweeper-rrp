import { asyncFilterMap } from "@alexaegis/common";
import { readFile } from "node:fs/promises";
import { join } from "node:path";
import { n as normalizeCollectFileDirnamesUpDirectoryTreeOptions, g as getWorkspaceRoot, c as collectFileDirnamePathsUpDirectoryTree, P as PACKAGE_JSON_DEPENDENCY_FIELDS } from "./get-workspace-root.function-afacc361.js";
import { N, a, b } from "./get-workspace-root.function-afacc361.js";
import { NEWLINE, HASH_COMMENT } from "@alexaegis/fs";
import "@alexaegis/match";
import "globby";
import "@alexaegis/logging";
import { collectWorkspacePackages, normalizeCollectWorkspacePackagesOptions } from "./monorepo.js";
import { getCurrentPackageRoot } from "./npm.js";
import { n } from "./normalize-package-json-workspaces-field.function-dbd5a9e0.js";
import { DEFAULT_PACKAGE_JSON_SORTING_PREFERENCE, createJsonSortingPreferenceNormalizer, normalizeSortingPreferenceForPackageJson } from "./sort.js";
import "node:fs";
const GITIGNORE_FILENAME = ".gitignore";
const normalizeCollectIgnoreEntriesOptions = (options) => {
  return {
    ...normalizeCollectFileDirnamesUpDirectoryTreeOptions(options),
    ignoreFileName: options?.ignoreFileName ?? GITIGNORE_FILENAME
  };
};
const splitAndStripHashComments = (content) => {
  return content.split(NEWLINE).map((line) => line.replace(HASH_COMMENT, "").trim()).filter((line) => !!line);
};
const collectIgnoreEntries = async (rawOptions) => {
  const options = normalizeCollectIgnoreEntriesOptions(rawOptions);
  const workspaceRoot = getWorkspaceRoot();
  if (!workspaceRoot) {
    throw new Error("Not in a workspace!");
  }
  const ignoreFileDirnames = collectFileDirnamePathsUpDirectoryTree(
    options.ignoreFileName,
    options
  );
  const ignoreFilePathsWithinWorkspace = ignoreFileDirnames.filter((ignoreFileDirname) => ignoreFileDirname.startsWith(workspaceRoot)).map((ignoreFileDirname) => join(ignoreFileDirname, options.ignoreFileName));
  const ignoreFileLines = await asyncFilterMap(
    ignoreFilePathsWithinWorkspace,
    async (ignoreFile) => {
      const gitIgnoreFile = await readFile(ignoreFile, {
        encoding: "utf8"
      });
      return splitAndStripHashComments(gitIgnoreFile);
    }
  );
  return ignoreFileLines.flat();
};
const getPackageJsonTemplateVariables = (packageJson) => {
  const packageName = packageJson.name ?? "";
  let packageOrg;
  let packageNameWithoutOrg = packageName;
  if (packageName.includes("/")) {
    const [splitPackageOrg, ...splitPackageName] = packageName.split("/");
    packageOrg = splitPackageOrg;
    packageNameWithoutOrg = splitPackageName.join("/");
  }
  return {
    packageOrg: packageOrg ?? "",
    packageName,
    packageNameWithoutOrg
  };
};
const isPackageJsonDependencyField = (field) => {
  return PACKAGE_JSON_DEPENDENCY_FIELDS.includes(field);
};
const getEncodedArchetype = (archetypeMatcher) => {
  if (!archetypeMatcher || typeof archetypeMatcher === "function") {
    return "";
  }
  const orderedValues = [
    archetypeMatcher.platform,
    archetypeMatcher.framework,
    archetypeMatcher.language,
    archetypeMatcher.kind,
    archetypeMatcher.bundler,
    archetypeMatcher.testing
  ];
  return orderedValues.filter((value) => typeof value === "string").join("-");
};
export {
  DEFAULT_PACKAGE_JSON_SORTING_PREFERENCE,
  N as NODE_MODULES_DIRECTORY_NAME,
  PACKAGE_JSON_DEPENDENCY_FIELDS,
  a as PACKAGE_JSON_NAME,
  b as PNPM_WORKSPACE_FILE_NAME,
  collectFileDirnamePathsUpDirectoryTree,
  collectIgnoreEntries,
  collectWorkspacePackages,
  createJsonSortingPreferenceNormalizer,
  getCurrentPackageRoot,
  getEncodedArchetype,
  getPackageJsonTemplateVariables,
  getWorkspaceRoot,
  isPackageJsonDependencyField,
  normalizeCollectWorkspacePackagesOptions,
  n as normalizePackageJsonWorkspacesField,
  normalizeSortingPreferenceForPackageJson,
  splitAndStripHashComments
};
