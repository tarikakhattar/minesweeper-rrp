"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const common = require("@alexaegis/common");
const fs = require("@alexaegis/fs");
const match = require("@alexaegis/match");
const globby = require("globby");
const node_path = require("node:path");
const getWorkspaceRoot_function = require("./get-workspace-root.function-6b16fefb.cjs");
const logging = require("@alexaegis/logging");
const normalizePackageJsonWorkspacesField_function = require("./normalize-package-json-workspaces-field.function-e1857a1b.cjs");
require("node:fs");
const normalizeGetRootPackageJsonOptions = (options) => {
  return {
    ...fs.normalizeCwdOption(options),
    ...logging.normalizeLoggerOption(options)
  };
};
const getRootPackageJson = async (rawOptions) => {
  const options = normalizeGetRootPackageJsonOptions(rawOptions);
  const rootWorkspace = getWorkspaceRoot_function.getWorkspaceRoot(options);
  if (!rootWorkspace) {
    options.logger.error("No package json was found! Cannot collect workspace packages!");
    return void 0;
  }
  const packageJsonPath = node_path.join(rootWorkspace, getWorkspaceRoot_function.PACKAGE_JSON_NAME);
  const packageJson = await fs.readJson(packageJsonPath).catch(() => void 0);
  if (!packageJson) {
    options.logger.error("Failed to read packageJson!", packageJsonPath);
    return void 0;
  }
  let workspaces = normalizePackageJsonWorkspacesField_function.normalizePackageJsonWorkspacesField(packageJson.workspaces);
  const pnpmWorkspace = await fs.readYaml(
    node_path.join(rootWorkspace, getWorkspaceRoot_function.PNPM_WORKSPACE_FILE_NAME)
  );
  if (pnpmWorkspace?.packages) {
    workspaces = [...workspaces, ...pnpmWorkspace.packages];
  }
  return {
    packageJson,
    packageKind: "root",
    workspacePackagePatterns: workspaces,
    packageJsonPath,
    packagePath: rootWorkspace,
    packagePathFromRootPackage: "."
  };
};
const normalizeCollectWorkspacePackagesOptions = (options) => {
  return {
    ...normalizeGetRootPackageJsonOptions(options),
    onlyWorkspaceRoot: options?.onlyWorkspaceRoot ?? false,
    skipWorkspaceRoot: options?.skipWorkspaceRoot ?? false,
    dependencyCriteria: options?.dependencyCriteria?.map(common.normalizeRegExpLikeToRegExp) ?? [],
    packageJsonMatcher: options?.packageJsonMatcher
  };
};
const collectWorkspacePackages = async (rawOptions) => {
  const options = normalizeCollectWorkspacePackagesOptions(rawOptions);
  const rootPackage = await getRootPackageJson(options);
  if (!rootPackage) {
    options.logger.error("No package json was found! Cannot collect workspace packages!");
    return [];
  }
  let result = [];
  if (rootPackage.workspacePackagePatterns.length > 0) {
    const paths = await globby.globby(rootPackage.workspacePackagePatterns, {
      gitignore: true,
      onlyDirectories: true,
      ignore: [getWorkspaceRoot_function.NODE_MODULES_DIRECTORY_NAME],
      absolute: true,
      cwd: rootPackage.packagePath
    });
    const subPackages = await common.asyncFilterMap(paths, (path) => {
      const packageJsonPath = node_path.join(path, getWorkspaceRoot_function.PACKAGE_JSON_NAME);
      return fs.readJson(packageJsonPath).catch(() => void 0).then(
        (packageJson) => packageJson ? {
          packageKind: "regular",
          packageJson,
          packagePath: path,
          packagePathFromRootPackage: node_path.relative(rootPackage.packagePath, path),
          packageJsonPath
        } : void 0
      );
    });
    if (!options.onlyWorkspaceRoot) {
      result.push(...subPackages);
    }
  }
  if (!options.skipWorkspaceRoot || rootPackage.workspacePackagePatterns.length === 0) {
    result.unshift(rootPackage);
  }
  if (options.packageJsonMatcher) {
    result = result.filter(
      (relativePackage) => match.match(relativePackage.packageJson, options.packageJsonMatcher)
    );
  }
  if (options.dependencyCriteria.length > 0) {
    result = result.filter((relativePackage) => {
      const packageDependencies = [
        ...Object.keys(relativePackage.packageJson.dependencies ?? {}),
        ...Object.keys(relativePackage.packageJson.devDependencies ?? {})
      ];
      return options.dependencyCriteria.every(
        (dependencyCriteria) => packageDependencies.some((dependency) => dependencyCriteria.test(dependency))
      );
    });
  }
  return result;
};
exports.collectWorkspacePackages = collectWorkspacePackages;
exports.normalizeCollectWorkspacePackagesOptions = normalizeCollectWorkspacePackagesOptions;
