import { normalizeRegExpLikeToRegExp, asyncFilterMap } from "@alexaegis/common";
import { normalizeCwdOption, readJson, readYaml } from "@alexaegis/fs";
import { match } from "@alexaegis/match";
import { globby } from "globby";
import { join, relative } from "node:path";
import { g as getWorkspaceRoot, a as PACKAGE_JSON_NAME, b as PNPM_WORKSPACE_FILE_NAME, N as NODE_MODULES_DIRECTORY_NAME } from "./get-workspace-root.function-afacc361.js";
import { normalizeLoggerOption } from "@alexaegis/logging";
import { n as normalizePackageJsonWorkspacesField } from "./normalize-package-json-workspaces-field.function-dbd5a9e0.js";
import "node:fs";
const normalizeGetRootPackageJsonOptions = (options) => {
  return {
    ...normalizeCwdOption(options),
    ...normalizeLoggerOption(options)
  };
};
const getRootPackageJson = async (rawOptions) => {
  const options = normalizeGetRootPackageJsonOptions(rawOptions);
  const rootWorkspace = getWorkspaceRoot(options);
  if (!rootWorkspace) {
    options.logger.error("No package json was found! Cannot collect workspace packages!");
    return void 0;
  }
  const packageJsonPath = join(rootWorkspace, PACKAGE_JSON_NAME);
  const packageJson = await readJson(packageJsonPath).catch(() => void 0);
  if (!packageJson) {
    options.logger.error("Failed to read packageJson!", packageJsonPath);
    return void 0;
  }
  let workspaces = normalizePackageJsonWorkspacesField(packageJson.workspaces);
  const pnpmWorkspace = await readYaml(
    join(rootWorkspace, PNPM_WORKSPACE_FILE_NAME)
  );
  if (pnpmWorkspace?.packages) {
    workspaces = [...workspaces, ...pnpmWorkspace.packages];
  }
  return {
    packageJson,
    packageKind: "root",
    workspacePackagePatterns: workspaces,
    packageJsonPath,
    packagePath: rootWorkspace,
    packagePathFromRootPackage: "."
  };
};
const normalizeCollectWorkspacePackagesOptions = (options) => {
  return {
    ...normalizeGetRootPackageJsonOptions(options),
    onlyWorkspaceRoot: options?.onlyWorkspaceRoot ?? false,
    skipWorkspaceRoot: options?.skipWorkspaceRoot ?? false,
    dependencyCriteria: options?.dependencyCriteria?.map(normalizeRegExpLikeToRegExp) ?? [],
    packageJsonMatcher: options?.packageJsonMatcher
  };
};
const collectWorkspacePackages = async (rawOptions) => {
  const options = normalizeCollectWorkspacePackagesOptions(rawOptions);
  const rootPackage = await getRootPackageJson(options);
  if (!rootPackage) {
    options.logger.error("No package json was found! Cannot collect workspace packages!");
    return [];
  }
  let result = [];
  if (rootPackage.workspacePackagePatterns.length > 0) {
    const paths = await globby(rootPackage.workspacePackagePatterns, {
      gitignore: true,
      onlyDirectories: true,
      ignore: [NODE_MODULES_DIRECTORY_NAME],
      absolute: true,
      cwd: rootPackage.packagePath
    });
    const subPackages = await asyncFilterMap(paths, (path) => {
      const packageJsonPath = join(path, PACKAGE_JSON_NAME);
      return readJson(packageJsonPath).catch(() => void 0).then(
        (packageJson) => packageJson ? {
          packageKind: "regular",
          packageJson,
          packagePath: path,
          packagePathFromRootPackage: relative(rootPackage.packagePath, path),
          packageJsonPath
        } : void 0
      );
    });
    if (!options.onlyWorkspaceRoot) {
      result.push(...subPackages);
    }
  }
  if (!options.skipWorkspaceRoot || rootPackage.workspacePackagePatterns.length === 0) {
    result.unshift(rootPackage);
  }
  if (options.packageJsonMatcher) {
    result = result.filter(
      (relativePackage) => match(relativePackage.packageJson, options.packageJsonMatcher)
    );
  }
  if (options.dependencyCriteria.length > 0) {
    result = result.filter((relativePackage) => {
      const packageDependencies = [
        ...Object.keys(relativePackage.packageJson.dependencies ?? {}),
        ...Object.keys(relativePackage.packageJson.devDependencies ?? {})
      ];
      return options.dependencyCriteria.every(
        (dependencyCriteria) => packageDependencies.some((dependency) => dependencyCriteria.test(dependency))
      );
    });
  }
  return result;
};
export {
  collectWorkspacePackages,
  normalizeCollectWorkspacePackagesOptions
};
