import { isNullish, asyncMap, isNotNullish, asyncFilterMap, isObject, deepFreeze, sleep } from "@alexaegis/common";
import { isPackageJsonDependencyField, collectWorkspacePackages } from "@alexaegis/workspace-tools";
import { isManagedContent, isManagedFile, AUTOTOOL_MARK, AUTOTOOL_PLUGIN_NAME_PREFIX, normalizeAutotoolOptions } from "autotool-plugin";
import { execSync } from "node:child_process";
import { existsSync } from "node:fs";
import { join, relative } from "node:path";
import { match } from "@alexaegis/match";
import { globby } from "globby";
import { readJson, normalizeCwdOption } from "@alexaegis/fs";
import diff from "microdiff";
import defaultPlugin from "autotool-plugin-default";
const checkIfTheresAnElementWithoutValidExecutor = (context, options) => {
  let failed = false;
  for (const plugin of context.plugins) {
    for (const element of plugin.elements ?? []) {
      if (!context.executorMap.has(element.executor)) {
        failed = true;
        options.logger.error(
          `Plugin ${plugin.name} contains an element with no executor: ${element.executor}`
        );
      }
    }
  }
  return failed;
};
const combinedDescriptions = (elements) => {
  const combinedDescription = [
    ...new Set(elements.map((element) => element.description ?? ""))
  ].join("; ");
  return combinedDescription === "" ? void 0 : combinedDescription;
};
const consolidateElementsAndFilterOutNonExecutables = (elements, workspacePackage, executorMap, options) => {
  return [...executorMap.values()].flatMap((executor) => {
    const elementsOfExecutor = elements.filter(
      (packageElement) => packageElement.element.executor === executor.type
    );
    if (executor.consolidate) {
      const allElements = elementsOfExecutor.map((e) => e.element);
      options.logger.trace("elements before consolidation", allElements);
      const consolidated = executor.consolidate(allElements);
      options.logger.trace("elements after consolidation", consolidated);
      const combinedDescription = combinedDescriptions(allElements);
      if (isNullish(consolidated)) {
        return [];
      } else if (Array.isArray(consolidated)) {
        return consolidated.map((element) => ({
          element: { ...element, description: combinedDescription },
          sourcePlugin: executor.sourcePlugin,
          workspacePackage
        }));
      } else {
        consolidated.description = combinedDescription;
        return {
          element: consolidated,
          sourcePlugin: executor.sourcePlugin,
          workspacePackage
        };
      }
    } else {
      return elementsOfExecutor;
    }
  });
};
const installCommands = {
  npm: "npm install",
  pnpm: "pnpm install",
  yarn: "yarn install"
};
const evidenceMap = {
  pnpm: [
    (rootWorkspacePackage) => existsSync(join(rootWorkspacePackage.packagePath, "pnpm-lock.yaml")),
    (rootWorkspacePackage) => rootWorkspacePackage.packageJson.packageManager?.startsWith("pnpm") ?? false
  ],
  npm: [
    (rootWorkspacePackage) => existsSync(join(rootWorkspacePackage.packagePath, "package-lock.json")),
    (rootWorkspacePackage) => rootWorkspacePackage.packageJson.packageManager?.startsWith("npm") ?? false
  ],
  yarn: [
    (rootWorkspacePackage) => existsSync(join(rootWorkspacePackage.packagePath, "yarn.lock")),
    (rootWorkspacePackage) => rootWorkspacePackage.packageJson.packageManager?.startsWith("yarn") ?? false
  ]
};
const discoverPackageManager = async (rootWorkspacePackage, options) => {
  options.logger.trace("gathering evidence...");
  const results = await asyncMap(
    Object.entries(evidenceMap),
    async ([packageManagerName, evidences]) => {
      const evidenceFound = await asyncMap(
        evidences,
        async (evidence) => await evidence(rootWorkspacePackage, options)
      );
      return {
        packageManagerName,
        evidenceFound: evidenceFound.filter((result) => !!result).length
      };
    }
  );
  results.sort((a, b) => b.evidenceFound - a.evidenceFound);
  options.logger.trace("evidence found", results);
  const packageManagerWithMostEvidence = results[0]?.packageManagerName;
  if (!packageManagerWithMostEvidence) {
    throw new Error("No package manager can be determined!");
  }
  options.logger.trace("packageManagerWithMostEvidence", packageManagerWithMostEvidence);
  return {
    name: packageManagerWithMostEvidence,
    installCommand: installCommands[packageManagerWithMostEvidence]
  };
};
const elementAndPluginFilter = (workspacePackage, filter, plugin) => {
  const pluginPackageKind = filter.packageKind ?? "all";
  let result = pluginPackageKind === "all" || pluginPackageKind === workspacePackage.packageKind;
  if (isNotNullish(filter.packageJsonFilter)) {
    const packageJsonMatch = match(
      workspacePackage.packageJson,
      filter.packageJsonFilter
    );
    result = result && packageJsonMatch;
  }
  const disabledPlugins = workspacePackage.packageJson["archetype"]?.disabledPlugins;
  if (Array.isArray(disabledPlugins)) {
    result = result && !disabledPlugins.includes(plugin.name);
  }
  return result;
};
const filterElementsForPackage = (workspacePackage, setupPlugins) => {
  return {
    workspacePackage,
    elements: setupPlugins.filter((plugin) => elementAndPluginFilter(workspacePackage, plugin, plugin)).flatMap(
      (sourcePlugin) => sourcePlugin.elements?.filter(
        (element) => elementAndPluginFilter(workspacePackage, element, sourcePlugin)
      ).map((element) => {
        const { packageJsonFilter, packageKind, ...elementWithoutFilters } = element;
        return {
          element: elementWithoutFilters,
          sourcePlugin,
          workspacePackage
        };
      }) ?? []
    )
  };
};
const mapRecord = (record, mapFn) => {
  return Object.fromEntries(
    Object.entries(record).map(([key, item]) => [key, mapFn(item, key)])
  );
};
const isElementUntargeted = (element, executorMap) => {
  return isNullish(element.targetFile) && isNullish(element.targetFilePatterns) && isNullish(executorMap.get(element.executor)?.defaultTarget);
};
const isElementTargeted = (element, executorMap) => {
  return isNotNullish(element.targetFile) || isNotNullish(element.targetFilePatterns) || isNotNullish(executorMap.get(element.executor)?.defaultTarget);
};
const isPackageElementUntargeted = (packageElement, executorMap) => {
  return isElementUntargeted(packageElement.element, executorMap);
};
const isPackageElementTargeted = (packageElement, executorMap) => {
  return isElementTargeted(packageElement.element, executorMap);
};
const createIsPackageElementTargeted = (executorMap) => (packageElement) => isPackageElementTargeted(packageElement, executorMap);
const partition = (array, partitioner) => {
  const a = [];
  const b = [];
  for (const e of array) {
    if (partitioner(e)) {
      a.push(e);
    } else {
      b.push(e);
    }
  }
  return [a, b];
};
const normalizeElementTargets = async (workspacePackageWithElements, executorMap) => {
  const isTargeted = createIsPackageElementTargeted(executorMap);
  const [elementsWithTargeting, elementsWithoutTargeting] = partition(
    workspacePackageWithElements.elements,
    isTargeted
  );
  const elements = await asyncFilterMap(elementsWithTargeting, async (packageElement) => {
    const targetFiles = [];
    const defaultTarget = executorMap.get(packageElement.element.executor)?.defaultTarget;
    if (defaultTarget) {
      targetFiles.push(defaultTarget);
    }
    if (packageElement.element.targetFile) {
      if (typeof packageElement.element.targetFile === "string") {
        targetFiles.push(packageElement.element.targetFile);
      } else {
        targetFiles.push(...packageElement.element.targetFile);
      }
    }
    if (packageElement.element.targetFilePatterns) {
      const matchedFiles = await globby(packageElement.element.targetFilePatterns, {
        cwd: workspacePackageWithElements.workspacePackage.packagePath,
        dot: true,
        globstar: true,
        braceExpansion: true
      });
      targetFiles.push(...matchedFiles);
    }
    return {
      element: packageElement,
      resolvedTargetFiles: [...new Set(targetFiles)]
    };
  });
  return {
    ...workspacePackageWithElements,
    targetedElements: elements,
    untargetedElements: elementsWithoutTargeting
  };
};
const groupAndConsolidateElementsByTargetFile = async (workspacePackage, executorMap, options) => {
  const resolved = await normalizeElementTargets(workspacePackage, executorMap);
  const targetedElementsByFile = resolved.targetedElements.reduce((groups, next) => {
    for (const targetFile of next.resolvedTargetFiles) {
      groups[targetFile]?.push(next.element);
      if (!groups[targetFile]) {
        groups[targetFile] = [next.element];
      }
    }
    return groups;
  }, {});
  return {
    workspacePackage: resolved.workspacePackage,
    untargetedElements: resolved.untargetedElements,
    targetedElementsByFile: mapRecord(
      targetedElementsByFile,
      (elements) => consolidateElementsAndFilterOutNonExecutables(
        elements,
        resolved.workspacePackage,
        executorMap,
        options
      )
    )
  };
};
const isRootWorkspacePackage = (workspacePackage) => {
  return workspacePackage.packageKind === "root";
};
const autotoolPluginFilterPredicate = (pluginName, options) => {
  let isEnabled = true;
  if (options.enabledPlugins.length > 0) {
    isEnabled = options.enabledPlugins.some((enabledPlugin) => enabledPlugin.test(pluginName));
  }
  let isDisabled = false;
  if (options.disabledPlugins.length > 0) {
    isDisabled = options.disabledPlugins.some(
      (disabledPlugin) => disabledPlugin.test(pluginName)
    );
  }
  return isEnabled && !isDisabled || pluginName === "autotool-plugin-default";
};
const assignElementsToTargets = async (workspacePackages, context, options) => {
  const workspacePackagesWithElements = workspacePackages.filter(
    (workspacePackage) => isManagedContent(JSON.stringify(workspacePackage.packageJson))
  ).map((workspacePackage) => filterElementsForPackage(workspacePackage, context.plugins));
  return asyncMap(
    workspacePackagesWithElements,
    (workspacePackageWithElements) => groupAndConsolidateElementsByTargetFile(
      workspacePackageWithElements,
      context.executorMap,
      options
    )
  );
};
const executeElementsOnPackage = async (packageElements, rootWorkspacePackage, executorMap, elementOptions, options) => {
  const targetedEntries = Object.entries(packageElements.targetedElementsByFile);
  if (targetedEntries.length > 0) {
    options.logger.info(
      `processing elements targeting "${packageElements.workspacePackage.packagePathFromRootPackage}..."`
    );
  } else {
    options.logger.info(
      `no elements targeting "${packageElements.workspacePackage.packagePathFromRootPackage}"`
    );
  }
  for (const [target, elements] of targetedEntries) {
    options.logger.trace(
      `all elements on ${target}`,
      elements.map((element) => element.element.executor)
    );
  }
  const untarget = {
    targetFilePackageRelative: "",
    targetFilePath: "",
    targetFilePathAbsolute: "",
    targetPackage: packageElements.workspacePackage,
    rootPackage: rootWorkspacePackage
  };
  await Promise.allSettled(
    targetedEntries.map(async ([targetFile, elements]) => {
      const targetFilePathAbsolute = join(
        packageElements.workspacePackage.packagePath,
        targetFile
      );
      const bearsTheMark = await isManagedFile(targetFilePathAbsolute);
      if (!bearsTheMark) {
        if (options.force) {
          options.logger.warn(
            `Target file ${targetFile} at ${packageElements.workspacePackage.packagePath} bears no mark ("${AUTOTOOL_MARK}") but it's ignored because '--force' was used.`
          );
        } else {
          options.logger.warn(
            `Target file ${targetFile} at ${packageElements.workspacePackage.packagePath} bears no mark ("${AUTOTOOL_MARK}"), skipping!`
          );
          return;
        }
      }
      const target = {
        ...untarget,
        targetFilePackageRelative: targetFile,
        targetFilePath: relative(options.cwd, targetFilePathAbsolute),
        targetFilePathAbsolute
      };
      for (const resolvedElement of elements) {
        const executor = executorMap.get(resolvedElement.element.executor);
        if (executor) {
          const elementLogger = elementOptions.logger.getSubLogger({
            name: resolvedElement.element.executor
          });
          const logMessage = `element${resolvedElement.element.description ? ' "' + resolvedElement.element.description + '"' : ""} using "${executor.type}" on "${targetFile}" at "${packageElements.workspacePackage.packagePathFromRootPackage}"`;
          if (options.dry) {
            elementLogger.info("Dry execution, skipping " + logMessage);
          } else {
            if (options.dryish) {
              elementLogger.info("Dryish execution, running " + logMessage);
            } else {
              elementLogger.info("Executing " + logMessage);
            }
            await executor.execute(resolvedElement.element, target, {
              ...elementOptions,
              logger: elementLogger
            });
          }
        } else {
          throw new Error("Executor not found");
        }
      }
    })
  );
  for (const resolvedElement of packageElements.untargetedElements) {
    const executor = executorMap.get(resolvedElement.element.executor);
    if (executor) {
      const elementLogger = elementOptions.logger.getSubLogger({
        name: resolvedElement.element.executor
      });
      const logMessage = `element${resolvedElement.element.description ? ' "' + resolvedElement.element.description + '"' : ""} using "${executor.type}" at "${packageElements.workspacePackage.packagePathFromRootPackage}"`;
      if (options.dry) {
        elementLogger.info("Dry execution, skipping " + logMessage);
      } else {
        if (options.dryish) {
          elementLogger.info("Dryish execution, running " + logMessage);
        } else {
          elementLogger.info("Executing " + logMessage);
        }
        await executor.execute(resolvedElement.element, untarget, {
          ...elementOptions,
          logger: elementLogger
        });
      }
    } else {
      throw new Error("Executor not found");
    }
  }
  if (targetedEntries.length > 0) {
    options.logger.info("finished processing elements here!");
  }
  const finalPackageJson = await readJson(
    packageElements.workspacePackage.packageJsonPath
  );
  if (!finalPackageJson) {
    throw new Error("PackageJson got corrupted!");
  }
  const packageJsonDiff = diff(packageElements.workspacePackage.packageJson, finalPackageJson);
  const someDependencyChanged = packageJsonDiff.some(
    (difference) => isPackageJsonDependencyField(difference.path[0])
  );
  const addedAutotoolPlugins = packageJsonDiff.map((difference) => {
    const lastPathFragment = difference.path.at(-1);
    if (difference.type === "CREATE" && isPackageJsonDependencyField(difference.path[0]) && typeof lastPathFragment === "string" && lastPathFragment.includes(AUTOTOOL_PLUGIN_NAME_PREFIX)) {
      return lastPathFragment;
    }
    return void 0;
  }).filter(isNotNullish);
  return {
    packageElements,
    finalPackageJson,
    packageJsonDiff,
    someDependencyChanged,
    addedAutotoolPlugins
  };
};
const createExecutorMap = (plugins, options) => {
  return plugins.reduce((executorMap, plugin) => {
    if (plugin.executors) {
      plugin.executors;
      for (const [key, executor] of Object.entries(
        plugin.executors
      )) {
        if (key !== executor.type) {
          options.logger.warn(
            `Executor ${executor.type} was declared with the wrong key (${key}) in ${plugin.name}!`
          );
        }
        if (executorMap.has(executor.type)) {
          options.logger.warn(
            `Executor ${executor.type} already loaded! Plugin: ${plugin.name} trying to load it again!`
          );
        } else {
          executorMap.set(executor.type, {
            ...executor,
            sourcePlugin: plugin
          });
        }
      }
    }
    return executorMap;
  }, /* @__PURE__ */ new Map());
};
const findInstalledPlugins = async (rawOptions) => {
  const options = normalizeCwdOption(rawOptions);
  const results = await globby(
    [
      `node_modules/${AUTOTOOL_PLUGIN_NAME_PREFIX}-*`,
      `node_modules/@*/${AUTOTOOL_PLUGIN_NAME_PREFIX}*`
      // Not checking for a '-' to allow names like @org/autotool-plugin
    ],
    {
      onlyDirectories: true,
      deep: 2,
      gitignore: false,
      cwd: options.cwd
    }
  );
  return results.map((path) => path.replace("node_modules/", ""));
};
const isAutotoolPluginObject = (plugin) => {
  const assumed = plugin;
  return typeof assumed === "object" && !Array.isArray(assumed) && isObject(assumed) && Array.isArray(assumed.elements);
};
const loadPlugin = async (plugin, packageName, options) => {
  if (typeof plugin === "function") {
    const factoryResult = await plugin({
      ...options,
      logger: options.logger.getSubLogger({ name: packageName })
    });
    return Array.isArray(factoryResult) ? factoryResult : [factoryResult];
  } else if (isAutotoolPluginObject(plugin)) {
    return [plugin];
  } else {
    return [];
  }
};
const loadInstalledPlugins = async (plugins, options) => {
  const modules = await asyncFilterMap(
    plugins,
    (name) => import(name).then((mod) => ({ mod, name }))
  );
  const loadedPlugins = await asyncFilterMap(modules, async ({ mod, name }) => {
    const modulePrefDefault = await (mod.default ?? mod);
    const loadedPlugins2 = await (Array.isArray(modulePrefDefault) ? asyncFilterMap(
      modulePrefDefault.map((m) => loadPlugin(m, name, options)),
      async (m) => await m
    ) : loadPlugin(modulePrefDefault, name, options));
    return loadedPlugins2.flat(1).map((plugin) => ({ ...plugin, name: plugin.name || name })).filter(isAutotoolPluginObject);
  });
  const result = loadedPlugins.flat(1);
  result.unshift(defaultPlugin);
  deepFreeze(result);
  return result;
};
const loadContext = async (rootWorkspacePackage, options) => {
  const installedPlugins = await findInstalledPlugins(options);
  let plugins = await loadInstalledPlugins(
    installedPlugins,
    {
      ...options,
      rootWorkspacePackage
    }
  );
  const executorMap = createExecutorMap(plugins, options);
  const validators = plugins.flatMap((plugin) => plugin.validators ?? []);
  options.logger.trace("executors loaded:", [...executorMap.keys()]);
  plugins = plugins.filter((plugin) => autotoolPluginFilterPredicate(plugin.name, options));
  options.logger.info(
    "plugins loaded after filters:",
    plugins.map((plugin) => plugin.name)
  );
  return {
    plugins,
    validators,
    executorMap
  };
};
const reportElementError = (error, options) => {
  const affectedPlugins = `Affected plugin${error.sourcePlugins.length > 1 ? "s" : ""}: ${error.sourcePlugins.map((plugin) => plugin.name).join(", ")}`;
  const affectedElements = `Affected element${error.sourceElements.length > 1 ? "s" : ""}: ${error.sourceElements.map(
    (element) => element.executor + (element.description ? ' "' + element.description + '"' : "")
  ).join(", ")}`;
  options.logger.error(`Error: ${error.code}
	Reason: ${error.message}
	Target: ${error.targetFile}
	${affectedPlugins}
	${affectedElements}
	Workspace: ${error.workspacePackage.packagePath}`);
};
const validate = async (workspacePackagesWithElementsByTarget, context, elementOptions, options) => {
  const unflattenedErrors = await asyncMap(
    context.validators,
    async (validator) => {
      const elementErrors = await asyncMap(
        workspacePackagesWithElementsByTarget,
        async (workspacePackageElements) => {
          const validationErrors = await validator(
            workspacePackageElements,
            context.executorMap,
            elementOptions
          );
          return validationErrors.map((error) => ({
            ...error,
            workspacePackage: workspacePackageElements.workspacePackage
          }));
        }
      );
      return elementErrors.flat(1);
    }
  );
  const errors = unflattenedErrors.flat(1);
  if (errors.length > 0) {
    options.logger.error("Error detected within setup elements!");
    for (const error of errors) {
      reportElementError(error, options);
    }
    return false;
  } else {
    options.logger.info("Valid elements, proceeding");
    return true;
  }
};
const autotool = async (rawOptions) => {
  const options = normalizeAutotoolOptions(rawOptions);
  if (options.maxAllowedRecursion <= 0) {
    options.logger.info("recursive limit reached!");
    return;
  }
  const workspacePackages = await collectWorkspacePackages(rawOptions);
  const rootWorkspacePackage = workspacePackages.find(isRootWorkspacePackage);
  if (!rootWorkspacePackage) {
    options.logger.warn("cannot do setup, not in a workspace!");
    return;
  }
  const packageManager = await discoverPackageManager(rootWorkspacePackage, {
    ...options,
    logger: options.logger.getSubLogger({ name: "discoverPackageManager" })
  });
  const context = await loadContext(rootWorkspacePackage, options);
  if (checkIfTheresAnElementWithoutValidExecutor(context, options)) {
    return;
  }
  const workspacePackagesWithElementsByTarget = await assignElementsToTargets(
    workspacePackages,
    context,
    options
  );
  options.logger.trace(workspacePackagesWithElementsByTarget);
  const elementOptions = {
    logger: options.logger,
    cwd: options.cwd,
    dry: options.dryish,
    force: options.force,
    rootWorkspacePackage
  };
  const isValid = await validate(
    workspacePackagesWithElementsByTarget,
    context,
    elementOptions,
    options
  );
  if (isValid) {
    const results = await asyncMap(
      workspacePackagesWithElementsByTarget,
      async (workspacePackageElementsByTarget) => {
        const targetPackageLogger = options.logger.getSubLogger({
          name: workspacePackageElementsByTarget.workspacePackage.packagePathFromRootPackage.replace(
            /^\.$/,
            "workspace-root"
          )
        });
        return await executeElementsOnPackage(
          workspacePackageElementsByTarget,
          rootWorkspacePackage,
          context.executorMap,
          { ...elementOptions, logger: targetPackageLogger },
          {
            ...options,
            logger: targetPackageLogger
          }
        );
      }
    );
    const addedAutotoolPlugins = results.flatMap((result) => result.addedAutotoolPlugins).filter((pluginName) => autotoolPluginFilterPredicate(pluginName, options));
    if (results.some((result) => result.someDependencyChanged)) {
      options.logger.info(
        "Some dependencies have changed! Installing packages using",
        packageManager.name
      );
      execSync(packageManager.installCommand, {
        stdio: "inherit"
      });
      if (addedAutotoolPlugins.length > 0) {
        options.logger.info(
          "New autotool plugins have been added! Re-executing autotool!",
          addedAutotoolPlugins
        );
        options.logger.info(
          "Remaining recursions available:",
          options.maxAllowedRecursion - 1
        );
        await sleep(1e3);
        await autotool({
          ...options,
          maxAllowedRecursion: options.maxAllowedRecursion - 1
        });
        return;
      }
    }
  } else {
    options.logger.error("setup was not valid. exit without doing anything.");
  }
};
export {
  consolidateElementsAndFilterOutNonExecutables as a,
  isElementUntargeted as b,
  checkIfTheresAnElementWithoutValidExecutor as c,
  discoverPackageManager as d,
  elementAndPluginFilter as e,
  filterElementsForPackage as f,
  groupAndConsolidateElementsByTargetFile as g,
  isElementTargeted as h,
  installCommands as i,
  isPackageElementUntargeted as j,
  isPackageElementTargeted as k,
  createIsPackageElementTargeted as l,
  isRootWorkspacePackage as m,
  mapRecord as n,
  normalizeElementTargets as o,
  partition as p,
  autotoolPluginFilterPredicate as q,
  autotool as r,
  executeElementsOnPackage as s,
  findInstalledPlugins as t,
  isAutotoolPluginObject as u,
  loadPlugin as v,
  loadInstalledPlugins as w
};
