import { isNotNullish, noopAsync } from "@alexaegis/common";
import { getCurrentPackageRoot, NODE_MODULES_DIRECTORY_NAME, collectWorkspacePackages, collectIgnoreEntries } from "@alexaegis/workspace-tools";
import { spawn } from "node:child_process";
import { join } from "node:path";
import { normalizeCwdOption } from "@alexaegis/fs";
const normalizeTurbowatchLocalNodeModulesOptions = (options) => {
  return {
    ...normalizeCwdOption(options),
    deep: options?.deep ?? true,
    useGitIgnore: options?.useGitIgnore ?? false,
    logChangedFiles: options?.logChangedFiles ?? false,
    buildDependenciesScript: options?.buildDependenciesScript ?? "build:dependencies",
    packageManagerCommand: options?.packageManagerCommand ?? "pnpm",
    onFirstBuild: options?.onFirstBuild,
    devScript: options?.devScript ?? "dev_"
  };
};
const turbowatchLocalNodeModules = async (rawOptions) => {
  const options = normalizeTurbowatchLocalNodeModulesOptions(rawOptions);
  console.log("turbowatch started in", options.cwd);
  const currentPackagePath = getCurrentPackageRoot(options.cwd);
  if (!currentPackagePath) {
    throw new Error("Not in a package!");
  }
  const currentPackagesNodeModulesPath = join(currentPackagePath, NODE_MODULES_DIRECTORY_NAME);
  const workspacePackages = await collectWorkspacePackages({
    ...options,
    skipWorkspaceRoot: true
  });
  const doNotMatchPackageJson = ["not", ["match", "package.json", "basename"]];
  const matchInLocalPackageDirectories = [
    "anyof",
    ...workspacePackages.map((workspacePackage) => workspacePackage.packageJson.name).filter(isNotNullish).map((packageName) => ["dirname", packageName])
  ];
  const commonIgnoredDirs = [
    ["dirname", "dist"],
    ["dirname", "out"],
    ["dirname", "build"],
    ["dirname", "coverage"],
    ["dirname", ".turbo"],
    ["dirname", ".vercel"],
    ["dirname", ".cache"],
    ["dirname", ".svelte-kit"],
    ["dirname", ".next"],
    ["match", "vite(st)?.config.*"]
  ];
  if (!options.deep) {
    commonIgnoredDirs.push(["dirname", "node_modules"]);
  }
  const doNotMatchCommonOutputs = ["not", ["anyof", ...commonIgnoredDirs]];
  const watchExpression = [
    "allof",
    matchInLocalPackageDirectories,
    doNotMatchCommonOutputs,
    doNotMatchPackageJson
  ];
  if (options.useGitIgnore) {
    let ignoreEntries = await collectIgnoreEntries(options);
    if (options.deep) {
      ignoreEntries = ignoreEntries.filter(
        (entry) => !entry.includes(NODE_MODULES_DIRECTORY_NAME)
      );
    }
    const ignoreMatchEntries = ignoreEntries.map((ignoreEntry) => [
      "match",
      ignoreEntry
    ]);
    const doNotMatchIgnored = ["not", ["anyof", ...ignoreMatchEntries]];
    watchExpression.push(doNotMatchIgnored);
  }
  let changeCount = 0;
  const startCommand = () => {
    return spawn(options.packageManagerCommand, ["run", options.devScript], {
      stdio: "inherit"
    });
  };
  let spawnedOnFirstBuild;
  const abortController = new AbortController();
  return {
    project: currentPackagesNodeModulesPath,
    debounce: { wait: 50 },
    abortController,
    triggers: [
      {
        expression: watchExpression,
        name: "build",
        retry: { retries: 0 },
        onChange: async ({ spawn: spawn2, files }) => {
          if (options.logChangedFiles) {
            console.log("changed files:", files);
          }
          await spawn2`${options.packageManagerCommand} run ${options.buildDependenciesScript}`;
          if (changeCount < 1) {
            spawnedOnFirstBuild = options.onFirstBuild ? options.onFirstBuild() : startCommand();
            if (spawnedOnFirstBuild) {
              spawnedOnFirstBuild.on("exit", () => {
                abortController.abort("onFirstBuild command exited!");
              });
            }
          }
          changeCount++;
        },
        onTeardown: async () => {
          if (spawnedOnFirstBuild) {
            spawnedOnFirstBuild.kill();
          }
          await noopAsync();
        }
      }
    ]
  };
};
export {
  normalizeTurbowatchLocalNodeModulesOptions,
  turbowatchLocalNodeModules
};
