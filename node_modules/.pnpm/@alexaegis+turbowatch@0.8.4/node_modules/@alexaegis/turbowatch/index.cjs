"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const common = require("@alexaegis/common");
const workspaceTools = require("@alexaegis/workspace-tools");
const node_child_process = require("node:child_process");
const node_path = require("node:path");
const fs = require("@alexaegis/fs");
const normalizeTurbowatchLocalNodeModulesOptions = (options) => {
  return {
    ...fs.normalizeCwdOption(options),
    deep: options?.deep ?? true,
    useGitIgnore: options?.useGitIgnore ?? false,
    logChangedFiles: options?.logChangedFiles ?? false,
    buildDependenciesScript: options?.buildDependenciesScript ?? "build:dependencies",
    packageManagerCommand: options?.packageManagerCommand ?? "pnpm",
    onFirstBuild: options?.onFirstBuild,
    devScript: options?.devScript ?? "dev_"
  };
};
const turbowatchLocalNodeModules = async (rawOptions) => {
  const options = normalizeTurbowatchLocalNodeModulesOptions(rawOptions);
  console.log("turbowatch started in", options.cwd);
  const currentPackagePath = workspaceTools.getCurrentPackageRoot(options.cwd);
  if (!currentPackagePath) {
    throw new Error("Not in a package!");
  }
  const currentPackagesNodeModulesPath = node_path.join(currentPackagePath, workspaceTools.NODE_MODULES_DIRECTORY_NAME);
  const workspacePackages = await workspaceTools.collectWorkspacePackages({
    ...options,
    skipWorkspaceRoot: true
  });
  const doNotMatchPackageJson = ["not", ["match", "package.json", "basename"]];
  const matchInLocalPackageDirectories = [
    "anyof",
    ...workspacePackages.map((workspacePackage) => workspacePackage.packageJson.name).filter(common.isNotNullish).map((packageName) => ["dirname", packageName])
  ];
  const commonIgnoredDirs = [
    ["dirname", "dist"],
    ["dirname", "out"],
    ["dirname", "build"],
    ["dirname", "coverage"],
    ["dirname", ".turbo"],
    ["dirname", ".vercel"],
    ["dirname", ".cache"],
    ["dirname", ".svelte-kit"],
    ["dirname", ".next"],
    ["match", "vite(st)?.config.*"]
  ];
  if (!options.deep) {
    commonIgnoredDirs.push(["dirname", "node_modules"]);
  }
  const doNotMatchCommonOutputs = ["not", ["anyof", ...commonIgnoredDirs]];
  const watchExpression = [
    "allof",
    matchInLocalPackageDirectories,
    doNotMatchCommonOutputs,
    doNotMatchPackageJson
  ];
  if (options.useGitIgnore) {
    let ignoreEntries = await workspaceTools.collectIgnoreEntries(options);
    if (options.deep) {
      ignoreEntries = ignoreEntries.filter(
        (entry) => !entry.includes(workspaceTools.NODE_MODULES_DIRECTORY_NAME)
      );
    }
    const ignoreMatchEntries = ignoreEntries.map((ignoreEntry) => [
      "match",
      ignoreEntry
    ]);
    const doNotMatchIgnored = ["not", ["anyof", ...ignoreMatchEntries]];
    watchExpression.push(doNotMatchIgnored);
  }
  let changeCount = 0;
  const startCommand = () => {
    return node_child_process.spawn(options.packageManagerCommand, ["run", options.devScript], {
      stdio: "inherit"
    });
  };
  let spawnedOnFirstBuild;
  const abortController = new AbortController();
  return {
    project: currentPackagesNodeModulesPath,
    debounce: { wait: 50 },
    abortController,
    triggers: [
      {
        expression: watchExpression,
        name: "build",
        retry: { retries: 0 },
        onChange: async ({ spawn: spawn2, files }) => {
          if (options.logChangedFiles) {
            console.log("changed files:", files);
          }
          await spawn2`${options.packageManagerCommand} run ${options.buildDependenciesScript}`;
          if (changeCount < 1) {
            spawnedOnFirstBuild = options.onFirstBuild ? options.onFirstBuild() : startCommand();
            if (spawnedOnFirstBuild) {
              spawnedOnFirstBuild.on("exit", () => {
                abortController.abort("onFirstBuild command exited!");
              });
            }
          }
          changeCount++;
        },
        onTeardown: async () => {
          if (spawnedOnFirstBuild) {
            spawnedOnFirstBuild.kill();
          }
          await common.noopAsync();
        }
      }
    ]
  };
};
exports.normalizeTurbowatchLocalNodeModulesOptions = normalizeTurbowatchLocalNodeModulesOptions;
exports.turbowatchLocalNodeModules = turbowatchLocalNodeModules;
