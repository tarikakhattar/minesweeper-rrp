export type JsonLeafValue = string | number | boolean | undefined | null;
export interface JsonObject {
    [key: string | number]: JsonObject | JsonLeafValue | (JsonObject | JsonLeafValue)[];
}
export type JsonValue = JsonObject[keyof JsonObject];
/**
 * A simple predicate. Returing undefined is the same thing as false.
 */
export type CustomJsonValueMatcher<T = JsonValue> = (value: T) => boolean | undefined;
export type JsonLeafMatcher = string | number | boolean | RegExp | CustomJsonValueMatcher;
export interface JsonObjectMatcher {
    [key: string | number]: JsonObjectMatcher | JsonLeafMatcher | (JsonObjectMatcher | JsonLeafMatcher)[];
}
export type JsonMatcher = JsonObjectMatcher[keyof JsonObjectMatcher];
/**
 * Turns a type into one that describes a valid matcher object for it.
 *
 * Beautiful.
 */
export type JsonMatcherFrom<T> = CustomJsonValueMatcher<T> | (T extends string ? T | RegExp : T extends object ? {
    [K in keyof T]?: JsonMatcherFrom<T[K]>;
} : T extends (infer R)[] ? JsonMatcherFrom<R>[] : T);
/**
 * TODO: Options to set if extra keys are allowed or not, currently it's allowed
 */
export declare const match: <T = JsonValue>(target: T, matcher: JsonMatcherFrom<T> | null | undefined) => boolean;
//# sourceMappingURL=match.function.d.ts.map