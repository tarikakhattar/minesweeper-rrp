#!/usr/bin/env node

import { YargsBuilder, yargsForLogLevelOption, yargsForCwdOption, yargsForDryOption } from "@alexaegis/cli-tools";
import { createLogger } from "@alexaegis/logging";
import { p as packageJson } from "../package-7ee32a93.js";
import { p as pakkStandaloneRunner } from "../pakk-standalone-runner.function-81c07586.js";
import { DEFAULT_BIN_GLOB, DEFAULT_PACKAGE_EXPORT_IGNORES, DEFAULT_BIN_DIR, ALL_NPM_HOOKS, DEFAULT_BINSHIM_DIR, DEFAULT_STATIC_EXPORT_GLOBS, DEFAULT_PACKAGE_EXPORTS, DEFAULT_PACKAGE_EXPORT_BASEDIR, PackageJsonExportTarget, DEFAULT_AUTO_METADATA_KEYS_FROM_WORKSPACE, PACKAGE_JSON_KIND, pakkFeatures, ALL_VITE_LIBRARY_FORMATS } from "@pakk/core";
import "@alexaegis/common";
import "@alexaegis/fs";
const yargsForAutoBin = (yargs) => {
  return yargs.group(
    ["bins", "binIgnore", "defaultBinIgnore", "binBaseDir", "enabledNpmHooks", "shimDir"],
    "auto-bin"
  ).option("bins", {
    description: "The files to treat as bins elative from the `srcDir + binBaseDir` directory.",
    string: true,
    array: true,
    default: DEFAULT_BIN_GLOB
  }).option("binIgnore", {
    description: "What paths to ignore when collecting bins in addition to `defaultBinIgnore` so you're not dropping the defaults when you just want to add additional ignore entries.",
    string: true,
    array: true,
    default: []
  }).option("defaultBinIgnore", {
    description: "By default test files are excluded",
    string: true,
    array: true,
    default: DEFAULT_PACKAGE_EXPORT_IGNORES
  }).option("binBaseDir", {
    description: "Relative path from `srcDir` if you want your exports to start from a different directory.",
    string: true,
    default: DEFAULT_BIN_DIR
  }).option("enabledNpmHooks", {
    description: "If a bin's name matches with an entry here (which is by default every NPM hook, 'postinstall' 'prebuild' etc.) then it will be automatically added to your packageJson file's scripts. To not interfere with development, hooks invoked during install are disabled for the source packageJson and are only avilable in the distributed packageJson.",
    string: true,
    array: true,
    default: ALL_NPM_HOOKS
  }).option("shimDir", {
    description: "A directory where shims for the built bins would be placed.",
    string: true,
    default: DEFAULT_BINSHIM_DIR
  });
};
const yargsForAutoExportStatic = (yargs) => {
  return yargs.group(["staticExports"], "auto-export-static").option("staticExports", {
    description: " Relative to cwd, a folder whats content will be simply copied to`outDir` and made available using simple, additional export statements.Make sure their names don't overlap with other exports!",
    string: true,
    array: true,
    default: DEFAULT_STATIC_EXPORT_GLOBS
  });
};
const yargsForAutoExport = (yargs) => {
  return yargs.group(
    [
      "exports",
      "exportsIgnore",
      "defaultExportsIgnore",
      "exportBaseDir",
      "developmentPackageJsonExportsTarget"
    ],
    "auto-export"
  ).option("exports", {
    description: "The files to treat as entry points to be exported from relative from the `srcDir + exportBaseDir` directory. It's usually `*` meaning all files directly here are considered the entry points of the library.",
    string: true,
    array: true,
    default: DEFAULT_PACKAGE_EXPORTS
  }).option("exportsIgnore", {
    description: "What paths to ignore when collecting exports in addition to `defaultExportsIgnore` so you're not dropping the defaults when you just  want to add additional ignore entries.",
    string: true,
    array: true,
    default: []
  }).option("defaultExportsIgnore", {
    description: "By default test files are excluded. This option is here if you deliberately want to drop the default ignores. Otherwise use `exportsIgnore`.",
    string: true,
    array: true,
    default: DEFAULT_PACKAGE_EXPORT_IGNORES
  }).option("exportBaseDir", {
    description: "Relative path to `srcDir` if you want your exports to start from a different directory.",
    string: true,
    default: DEFAULT_PACKAGE_EXPORT_BASEDIR
  }).option("developmentPackageJsonExportsTarget", {
    description: "Where should exports point to in your development packageJson file",
    string: true,
    choices: [PackageJsonExportTarget.DIST, PackageJsonExportTarget.SOURCE],
    default: PackageJsonExportTarget.DIST
  });
};
const yargsForAutoMetadata = (yargs) => {
  return yargs.group(["keysFromWorkspace", "mandatoryKeys"], "auto-metadata").option("keysFromWorkspace", {
    description: "A list of packageJson keys from the workspace root package.json to autofill in built artifacts.",
    string: true,
    array: true,
    default: DEFAULT_AUTO_METADATA_KEYS_FROM_WORKSPACE
  }).option("mandatoryKeys", {
    description: "A list of packageJson keys from the workspace root package.json to autofill in built artifacts.",
    string: true,
    array: true,
    default: DEFAULT_AUTO_METADATA_KEYS_FROM_WORKSPACE
  });
};
const yargsForPakk = (yargs) => {
  return yargs.option("srcDir", {
    description: "Source root, relative to the package directory",
    string: true,
    default: "src"
  }).option("outDir", {
    description: "The expected output directory relative to the package's directory.",
    string: true,
    default: "dist"
  }).option("sourcePackageJson", {
    description: "packageJson to modify and put in the artifact, relative to the package's directory.",
    string: true,
    default: "package.json"
  }).option("autoPrettier", {
    description: "Enable prettier integration",
    boolean: true,
    default: true
  }).option("svelte", {
    description: "Features for svelte libraries, like defining svelte exports",
    boolean: true,
    default: false
  }).option("targetPackageJsonKind", {
    description: "Which packageJson to act on. Will do both when left empty.",
    choices: Object.values(PACKAGE_JSON_KIND),
    default: void 0
  }).option("enabledFeatures", {
    description: "When defined only these features will be enabled.",
    choices: pakkFeatures,
    array: true,
    string: true
  }).option("disabledFeatures", {
    description: "When defined these features will be disabled.",
    choices: pakkFeatures,
    array: true,
    string: true
  }).option("formats", {
    description: "What library formats to expect to be output",
    choices: ALL_VITE_LIBRARY_FORMATS,
    array: true,
    string: true
  });
};
const yarguments = YargsBuilder.withDefaults(packageJson).add(yargsForPakk).add(yargsForLogLevelOption).add(yargsForAutoBin).add(yargsForAutoExport).add(yargsForAutoExportStatic).add(yargsForAutoMetadata).add(yargsForCwdOption).add(yargsForDryOption).build();
void (async () => {
  const options = await yarguments.parseAsync();
  const logger = createLogger({
    name: "pakk",
    minLevel: options.logLevel
  });
  logger.trace("Parsed options", options);
  await pakkStandaloneRunner({ ...options, logger });
})();
//# sourceMappingURL=pakk.js.map
