import { Observable, Subscription } from 'rxjs';
import type { Action, ActionConfig, ActionPacket } from '../action/index.js';
import { type GetNext, type NextKeyStrategy } from '../helper/index.js';
import type { TinySlicePlugin } from '../plugins/index.js';
import type { Merger } from './merger.type.js';
import type { MetaReducer, ReduceActionSliceSnapshot, ReducerConfiguration } from './reducer.type.js';
import type { Scope } from './scope.class.js';
import type { Selector } from './selector.type.js';
import type { StrictRuntimeChecks } from './strict-runtime-checks.interface.js';
export type ObjectKey = string | number | symbol;
export type UnknownObject<T = unknown> = Record<ObjectKey, T>;
export type SliceDetacher = () => void;
export interface DicedSlice<State, ChildState, ParentInternals, ChildInternals, DiceKey extends ObjectKey> {
    slice: Slice<unknown, State & Record<DiceKey, ChildState>, ParentInternals>;
    keys: () => DiceKey[];
    keys$: Observable<DiceKey[]>;
    count$: Observable<number>;
    items$: Observable<ChildState[]>;
    some$: (predicate: (item: ChildState) => boolean) => Observable<boolean>;
    every$: (predicate: (item: ChildState) => boolean) => Observable<boolean>;
    add: (data: ChildState) => void;
    create: () => void;
    set: (key: DiceKey, data: ChildState) => void;
    remove: (key: DiceKey) => void;
    getNextKey: () => DiceKey;
    has: (key: DiceKey) => boolean;
    get: (key: DiceKey) => Slice<State & Record<DiceKey, ChildState>, NonNullable<ChildState>, ChildInternals>;
    selectOnceDefined: (key: DiceKey) => Promise<Slice<State & Record<DiceKey, ChildState>, NonNullable<ChildState>, ChildInternals>>;
}
/**
 * This type can be used to get the Child slice signature of a diced slice
 * ```ts
 * const pieDice = pies$.dice({...});
 * DicedSliceChild<typeof pieDice>; // Slice<>
 * ```
 */
export type DicedSliceChild<D extends DicedSlice<any, any, any, any, any>> = ReturnType<D['get']>;
export interface SliceCoupling<ParentState, State> {
    parentSlice: Slice<unknown, ParentState, UnknownObject>;
    rawParentState: Observable<ParentState>;
    /**
     * Used to check the lifetime of the slice, once the key itself is removed
     * from the parent object, the subslice is completed.
     * Most subslices are attached via a key, only custom select baseds are not.
     */
    key: ObjectKey | undefined;
    slicer: SelectSlicer<ParentState, State>;
    droppable: boolean;
}
export interface SliceRegistration<ParentState, State, Internals> {
    slice: Slice<ParentState, State, Internals>;
    slicer: SelectSlicer<ParentState, State>;
    key: ObjectKey | undefined;
    initialState: State | undefined;
}
export interface SliceOptions<ParentState, State, Internals> {
    reducers?: ReducerConfiguration<State>[] | undefined;
    plugins?: TinySlicePlugin<State>[] | undefined;
    metaReducers?: MetaReducer[] | undefined;
    /**
     * ? Setting the passed slices Internal generic to unknown is crucial for
     * ? type inference to work
     */
    defineInternals?: ((slice: Slice<ParentState, State>) => Internals) | undefined;
}
export interface RootSliceOptions<State, Internals> extends SliceOptions<never, State, Internals> {
    /**
     * Runtime checks can slow the store down, turn them off in production,
     * they are all on by default.
     */
    runtimeChecks?: StrictRuntimeChecks;
}
export type RootSlice<State, Internals = unknown> = Slice<never, State, Internals>;
export interface SliceConstructOptions<ParentState, State, Internals> extends SliceOptions<ParentState, State, Internals> {
    scope: Scope;
    initialState: State;
    parentCoupling?: SliceCoupling<ParentState, State>;
    pathSegment: string;
}
export interface DiceConstructOptions<State, ChildState, ChildInternals, DiceKey> extends SliceOptions<State, ChildState, ChildInternals> {
    getAllKeys: (state: State) => DiceKey[];
    getNextKey: GetNext<DiceKey>;
}
export interface PremadeDiceConstructOptions<ParentState, State, ChildState, Internals, ChildInternals> extends SliceOptions<State, ChildState, ChildInternals> {
    getNextKeyStrategy?: NextKeyStrategy;
    dicedSliceOptions?: SliceOptions<ParentState, State, Internals>;
}
export interface ChildSliceConstructOptions<ParentState, State, Internals> extends SliceOptions<ParentState, State, Internals> {
    initialState?: State | undefined;
    /**
     * Marks if a slice should be dropped when its key is dropped from its
     * parent. It's generally only safe to do with dynamic slices (dices)
     * that are only accessed through lazy slice accessors
     */
    droppable: boolean;
    pathSegment: string;
    slicer: SelectSlicer<ParentState, State>;
    key: ObjectKey | undefined;
}
export interface SelectSlicer<ParentState, State> {
    selector: Selector<ParentState, State>;
    merger: Merger<ParentState, State>;
}
export interface SliceChange<State> {
    snapshot: ReduceActionSliceSnapshot<unknown>;
    sliceRegistration: SliceRegistration<State, unknown, unknown>;
}
/**
 * TODO: Create a variant where the key must not already be part of ParentState
 * TODO: and State must not already be a value of ParentState
 */
export type SliceDirection<ParentState, State> = string | number | symbol | keyof ParentState | SelectSlicer<ParentState, State>;
export declare const normalizeSliceDirection: <ParentState, State>(sliceDirection: SliceDirection<ParentState, State>) => SelectSlicer<ParentState, State>;
/**
 * It's pizza time!
 */
export declare class Slice<ParentState, State, Internals = unknown> extends Observable<State> {
    private readonly sink;
    private options;
    private scope;
    private initialState;
    private parentCoupling;
    private initialReducers;
    private initialPlugins;
    private state$;
    private _pathSegment;
    private _absolutePath;
    setAction: Action<State>;
    updateAction: Action<Partial<State>>;
    deleteKeyAction: Action<ObjectKey>;
    defineKeyAction: Action<{
        key: ObjectKey;
        data: unknown;
    }>;
    private observableState$;
    private defaultReducerConfigurations;
    private reducerConfigurations$;
    private autoRegisterReducerActions$;
    private downStreamReducers$;
    private sliceReducer$;
    private sliceReducingActions$;
    private plugins$;
    private autoRegisterPlugins$;
    private nullishParentPause$;
    private manualPause$;
    private pause$;
    private keyedSlices$;
    private slices$;
    subscribe: {
        (observerOrNext?: Partial<import("rxjs").Observer<NonNullable<State>>> | ((value: NonNullable<State>) => void) | undefined): Subscription;
        (next?: ((value: NonNullable<State>) => void) | null | undefined, error?: ((error: any) => void) | null | undefined, complete?: (() => void) | null | undefined): Subscription;
    };
    private parentListener;
    private inactivePipeline;
    private activePipeline;
    private pipeline;
    private defineInternals;
    private _internals;
    private scopedActions;
    get internals(): Internals;
    get absolutePath(): string;
    get pathSegment(): string;
    /**
     * For debugging purposes
     */
    printSliceStructure(indentationLevel?: number): void;
    /**
     *
     * @param initialState
     * @param sliceSegment a string that represents this slice, has to be
     * unique on it's parent.
     */
    private constructor();
    private executeMetaPreReducers;
    private executeMetaPostReducers;
    loadAndSetPlugins(...pluginImports: (() => Promise<TinySlicePlugin<State>>)[]): Promise<TinySlicePlugin<State>[]>;
    get paused$(): Observable<boolean>;
    /**
     * Unpauses this slice and every child slice recursively
     */
    unpause(): void;
    /**
     * Pauses this slice and every child slice recursively
     */
    pause(): void;
    /**
     * Effects created here will respond to the pause and unpauseEffects functions.
     * These effects will also unsubscribe if the slice unsubscribes
     */
    createEffect<Output>(packet$: Observable<Output | ActionPacket>): Subscription;
    setPlugins(plugins: TinySlicePlugin<State>[]): void;
    getPlugins(): TinySlicePlugin<State>[];
    addPlugin(...plugins: TinySlicePlugin<State>[]): void;
    getReducers(): ReducerConfiguration<State>[];
    /**
     * This does not disable default redurces.
     */
    setReducers(reducers: ReducerConfiguration<State>[]): void;
    addReducers(reducers: ReducerConfiguration<State>[]): void;
    static assembleAbsolutePath(parentAbsolutePath: string, segment: string): string;
    private static calculateAbsolutePath;
    private registerPlugin;
    set(slice: State | undefined): void;
    update(slice: Partial<State>): void;
    set value(value: State);
    get value(): State;
    private isRootOrParentStateUndefined;
    static createRootSlice<State, Internals>(scope: Scope, initialState: State, sliceOptions?: RootSliceOptions<State, Internals>): RootSlice<State, Internals>;
    createAction<Packet>(name: string, actionOptions?: ActionConfig): Action<Packet>;
    private sliceInternal;
    /**
     * @deprecated remove this, too much trouble because of selector.toString(), use dice instead
     */
    sliceSelect<ChildState extends State[keyof State], ChildInternals = unknown>(selector: Selector<State, ChildState>, merger: Merger<State, ChildState>, sliceOptions?: SliceOptions<State, ChildState, ChildInternals>): Slice<State, NonNullable<ChildState>, ChildInternals>;
    slice<ChildStateKey extends keyof State, ChildInternals>(key: ChildStateKey, sliceOptions?: SliceOptions<State, NonNullable<State[ChildStateKey]>, ChildInternals>): Slice<State, NonNullable<State[ChildStateKey]>, ChildInternals>;
    /**
     * Adds non-defined "lazy" slices to extend this slice
     * ? https://github.com/microsoft/TypeScript/issues/42315
     * ? key could be restricted to disallow keys of Slice once negated types
     * ? are implemented in TypeScript
     */
    addSlice<ChildState, ChildInternals, AdditionalKey extends ObjectKey = string>(key: AdditionalKey, initialState: ChildState, sliceOptions?: SliceOptions<State, ChildState, ChildInternals>): Slice<State & Record<AdditionalKey, ChildState>, NonNullable<ChildState>, ChildInternals>;
    /**
     * Adds a new lazy slice then dices it with a number type record,
     * you can choose between nextKeyStrategies:
     * - NEXT_SMALLEST
     * - NEXT_LARGEST,
     * - CUSTOM
     *
     * NEXT_LARGEST is the default as thats the simplest.
     *
     * ! make sure key doesn't exist via generics on State once that can be done in TS
     */
    addDicedSlice<Key extends ObjectKey, ChildState, DicedInternals, ChildInternals, DiceState extends Record<number, ChildState>>(key: Key extends keyof State ? never : Key, initialState: ChildState, diceConstructOptions: PremadeDiceConstructOptions<State, DiceState, ChildState, DicedInternals, ChildInternals>): DicedSlice<State, ChildState, DicedInternals, ChildInternals, number>;
    /**
     * This slice type is created on the fly for N subsclices of the same type
     * great for complex entities that spawn on the fly and have their own
     * state definition.
     *
     * This defines two layers of state at once. The middle layer stores the bottom layers
     * you can ask for bottom layers lazyly using a selector. You'll then receive the
     * slice object and, all the other guts you predefined, like state observers, actions, etc
     *
     * Actions are automatically scoped to these selected subslices
     *
     * Nomenclature: Slicing means to take a single piece of state, dicing is multiple
     */
    dice<ChildState, ChildInternals, DiceKey extends ObjectKey>(initialState: ChildState, diceConstructOptions: DiceConstructOptions<State, ChildState, ChildInternals, DiceKey>): DicedSlice<State, ChildState, Internals, ChildInternals, DiceKey>;
    private registerSlice;
    /**
     *
     * @param pathSegment single segment, not the entire absolutePath
     */
    unregisterSlice(pathSegment: string): void;
    /**
     * Tears down itself and anything below
     */
    complete(): void;
    asObservable(): Observable<State>;
}
//# sourceMappingURL=slice.class.d.ts.map