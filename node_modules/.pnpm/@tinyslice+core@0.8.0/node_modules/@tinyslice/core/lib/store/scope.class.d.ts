import { Observable, Subscription } from 'rxjs';
import type { ActionConfig } from '../action/action-config.interface.js';
import { type ActionPacket } from '../action/action-packet.interface.js';
import { Action, type ActionTuple } from '../action/action.class.js';
import { type RootSlice, type RootSliceOptions } from './slice.class.js';
/**
 * Defines a state scope on which actions act upon. The state machine is
 * scheduled by the scopes action dispatcher as reducers and plugins only
 * tick when an action is fired.
 */
export declare class Scope {
    private readonly schedulingDispatcher;
    private readonly actionMap;
    readonly schedulingDispatcher$: Observable<ActionPacket>;
    private readonly effectSubscriptions;
    private readonly stores;
    readonly slices: Map<string, unknown>;
    constructor();
    createAction<Payload = void>(type: string, config?: Partial<ActionConfig>): Action<Payload>;
    createRootSlice<State, Internals = unknown>(initialState: State, rootSliceOptions?: RootSliceOptions<State, Internals>): RootSlice<State, Internals>;
    /**
     * Using this ensures packets returned by effects are reduced on next tick.
     * Otherwise the normal reducer could overwrite whatever the effect
     * is producing.
     * Let's say you'd write a typical useless machine, if the effect notices
     * you set a boolean state to true, it sets it back to false immediately.
     * Without this scheduling, the effects result could happen before the
     * triggering actions reduce and the state would be left as true.
     */
    createEffect<Output>(action: Observable<Output | ActionPacket>): Subscription;
    /**
     * Only used for cleanup
     */
    registerRootSlice(store: RootSlice<unknown>): void;
    registerAction<Payload>(action: Action<Payload>, registerFromAction?: boolean): Subscription | undefined;
    listen$<T extends readonly unknown[]>(...actions: [...ActionTuple<T>]): Observable<ActionPacket<T[number]>>;
    listenAll$(): Observable<ActionPacket>;
    isRegistered<Payload>(action?: Action<Payload> | string): boolean;
    get closed(): boolean;
    complete(): void;
}
//# sourceMappingURL=scope.class.d.ts.map