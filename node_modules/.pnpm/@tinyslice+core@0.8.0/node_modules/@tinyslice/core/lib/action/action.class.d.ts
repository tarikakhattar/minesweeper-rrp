import { Observable, Subject, Subscription, type MonoTypeOperatorFunction } from 'rxjs';
import type { Scope } from '../store/index.js';
import type { ActionReducer, ReducerConfiguration } from '../store/reducer.type.js';
import { type ActionConfig } from './action-config.interface.js';
import type { ActionPacket } from './action-packet.interface.js';
export type ActionTuple<T> = {
    [K in keyof T]: Action<T[K]>;
};
export type ActionDispatch = () => void;
/**
 * TODO: Actions should be able to switch or hold multiple scopes
 * TODO: .and method to chain actions for multireducers and multieffects
 */
export declare class Action<Payload = void> extends Subject<Payload> {
    type: string;
    private dispatchSubscription?;
    private config;
    private scope;
    registrations: Subscription;
    /**
     * This will emit every action of this type, both direct dispatches and
     * effect dispatches
     */
    get listenPackets$(): Observable<ActionPacket<Payload>>;
    /**
     * This won't receive actions from effects
     */
    get listen$(): Observable<Payload>;
    private actionPipeline;
    /**
     * TODO: Make this private, refactor angular solution
     * @param type
     * @param config
     */
    constructor(type: string, config?: Partial<ActionConfig>);
    register(scope: Scope): this;
    unregister(): void;
    makePacket(payload: Payload): ActionPacket<Payload>;
    /**
     * The finalize operator will take care of removing it from the actionMap
     */
    complete(): void;
    /**
     *
     */
    getFilter(): MonoTypeOperatorFunction<ActionPacket<Payload>>;
    static makeFilter<T extends readonly unknown[]>(...actions: [...ActionTuple<T>]): MonoTypeOperatorFunction<ActionPacket<T[number]>>;
    reduce<State>(actionReducer: ActionReducer<State, Payload>): ReducerConfiguration<State, Payload>;
}
//# sourceMappingURL=action.class.d.ts.map