"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const common = require("@alexaegis/common");
const core = require("@tinyslice/core");
const brightFgColor = "#ffe36a";
const dimFgColor = "#f9c33c";
const defaultCss = `background: #222; color: ${brightFgColor};`;
const defaultCssDim = `background: #222; color: ${dimFgColor};`;
const successCss = `background: #090; color: ${brightFgColor};`;
const failCss = `background: #900; color: ${brightFgColor};`;
const normalCss = "background: #222; color: #fff;";
const hiddenCss = "background: #222; color: #444;";
const isSuccessMessage = (message) => message.toLowerCase().includes("success");
const isFailureMessage = (message) => message.toLowerCase().includes("fail");
const isErrorMessage = (message) => message.toLowerCase().includes("error");
const isTinySliceMessage = (message) => message.includes(core.TINYSLICE_PREFIX);
const getMessageCss = (message, isInternal) => {
  if (isSuccessMessage(message)) {
    return successCss;
  } else if (isFailureMessage(message) || isErrorMessage(message)) {
    return failCss;
  } else {
    return isInternal ? defaultCssDim : defaultCss;
  }
};
const bracketMatcher = /\[[^\]]*]/g;
const separateMessage = (message) => {
  const a = message.split(bracketMatcher);
  const b = message.match(bracketMatcher) ?? [];
  const result = [a[0]];
  for (let i = 1; i < a.length; i++) {
    result.push(b[i - 1], a[i]);
  }
  return result.filter(common.isNotNullish);
};
const colorizeLogString = (message) => {
  const segments = separateMessage(message);
  const codedSegments = [];
  const colorisedSegments = [];
  const isInternal = segments.some((segment) => isTinySliceMessage(segment));
  for (const segment of segments) {
    const css = getMessageCss(segment, isInternal);
    if (css) {
      codedSegments.push(`%c${segment}`);
      colorisedSegments.push(getMessageCss(segment, isInternal));
    } else {
      codedSegments.push(segment);
      colorisedSegments.push("");
    }
  }
  return ["ðŸ• " + codedSegments.join(""), ...colorisedSegments];
};
const DEFAULT_OPTIONS = {
  ignorePaths: [],
  ignoreActions: [],
  disableGrouping: false,
  onlyRoot: false,
  onlyTimers: false
};
class TinySliceLoggerPlugin {
  options;
  first = false;
  enabled = false;
  lastTimer = void 0;
  pluginOptions = {
    passToChildren: true
  };
  constructor(options) {
    this.options = {
      ...DEFAULT_OPTIONS,
      ...options
    };
  }
  isIgnored(path, actionPacket) {
    return this.options.ignorePaths.some(
      (pathIgnore) => typeof pathIgnore === "string" ? path.startsWith(pathIgnore) || actionPacket.type.startsWith(pathIgnore) : pathIgnore.test(path)
    ) || this.options.ignoreActions.some(
      (actionIgnore) => typeof actionIgnore === "string" ? actionIgnore === actionPacket.type : actionIgnore.test(actionPacket.type)
    );
  }
  sliceOptions() {
    return this.pluginOptions;
  }
  preRootReduce(absolutePath, _state, action) {
    this.first = true;
    if (this.enabled && !this.isIgnored(absolutePath, action)) {
      console.time("entire reduce took");
      if (this.options.disableGrouping) {
        console.log(...colorizeLogString(action.type));
      } else {
        console.groupCollapsed(...colorizeLogString(action.type));
      }
    }
  }
  preReduce(absolutePath, _state, action) {
    if (this.enabled && !this.options.onlyRoot && !this.isIgnored(absolutePath, action)) {
      this.lastTimer = `${absolutePath} reduce took`;
      console.time(this.lastTimer);
    }
  }
  postReduce(absolutePath, snapshot) {
    if (this.enabled && !this.options.onlyRoot && !this.isIgnored(absolutePath, snapshot.actionPacket)) {
      const changed = snapshot.prevState !== snapshot.nextState;
      const logCss = changed ? normalCss : hiddenCss;
      if (!this.options.onlyTimers) {
        if (this.options.disableGrouping) {
          console.log(`%c${absolutePath}`, logCss);
        } else {
          if (this.first) {
            this.first = false;
            console.group(`%c${absolutePath}`, logCss);
          } else {
            console.groupCollapsed(`%c${absolutePath}`, logCss);
          }
        }
        console.info("%cprevState", logCss, snapshot.prevState);
        console.info("%cpayload", logCss, snapshot.actionPacket.payload);
        console.info("%cnextState", logCss, snapshot.nextState);
      }
      console.timeEnd(`${absolutePath} reduce took`);
      if (!this.options.onlyTimers && !this.options.disableGrouping) {
        console.groupEnd();
      }
    }
  }
  postRootReduce(absolutePath, snapshot) {
    if (this.enabled && !this.isIgnored(absolutePath, snapshot.actionPacket)) {
      console.timeEnd("entire reduce took");
      if (!this.options.disableGrouping) {
        console.groupEnd();
      }
    }
  }
  start() {
    this.enabled = true;
    return void 0;
  }
  stop() {
    if (!this.options.disableGrouping) {
      if (this.lastTimer) {
        console.timeEnd(this.lastTimer);
      }
      console.groupEnd();
    }
    this.enabled = false;
    return void 0;
  }
  register(_hooks) {
    return void 0;
  }
}
exports.DEFAULT_OPTIONS = DEFAULT_OPTIONS;
exports.TinySliceLoggerPlugin = TinySliceLoggerPlugin;
exports.colorizeLogString = colorizeLogString;
